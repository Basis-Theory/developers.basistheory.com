---
toc_max_heading_level: 2
---

import { Alert, Alerts } from "@site/src/components/shared/Alert";
import JavaScript from "@site/static/img/sdk/logos/javascript.svg";
import Android from "@site/static/img/sdk/logos/android.svg";
import AppleDark from "@site/static/img/sdk/logos/apple-dark.svg";
import Apple from "@site/static/img/sdk/logos/apple.svg";
import React from "@site/static/img/sdk/logos/react.svg";
import { Card } from "@site/src/components/shared/Card";
import styles from "@site/src/pages/index.module.css";
import GettingStartedSection from "@site/src/components/docs/_getting-started-section.mdx";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ThemedImage from "@theme/ThemedImage";
import useBaseUrl from "@docusaurus/useBaseUrl";

# Authenticate Merchant Initiated Transactions (MITs) with 3DS

[3DS (3D Secure)](/docs/features/3d-secure) is an online payment authentication protocol that enhances anti-fraud efforts.
In the context of Merchant Initiated Transactions (MIT), such as recurring payments and subscriptions, 3DS operates differently.
Instead of requiring cardholders to undergo an additional layer of verification like a one-time password or biometric scan during each transaction, any necessary authentication challenges occur in a decoupled manner, typically during the initial setup of the payment agreement.
This approach allows merchants to process subsequent payments seamlessly without direct cardholder interaction, while still complying with Secure Customer Authentication (SCA) requirements under regulations like PSD2.

This guide will show you how to use the Basis Theory Platform to perform 3DS authentication for Merchant Initiated Transactions.

<Alert type={Alerts.INFO}>3D Secure is an Enterprise feature. Contact <a href="mailto:support@basistheory.com">support@basistheory.com</a> to request access.</Alert>

## Getting Started

<GettingStartedSection />

## Provisioning Resources

In this section, we will explore the bare minimum resources necessary to authenticate merchant transactions with 3DS.

### Public Application

You will need a [Public Application](/docs/api/applications) with permissions to create tokens and 3DS sessions. [Click here to create one](https://portal.basistheory.com/applications/create?permissions=token%3Acreate&permissions=3ds%3Asession%3Acreate&type=public).

This will create an application with the following Permissions:
* Permissions: `token:create`, `3ds:session:create`

<Alert>Save the API Key from the created Public Application as it will be used later in this guide.</Alert>

### Private Application

Next, you will need a [Private Application](/docs/api/applications) for your backend with the permission to authenticate 3DS sessions.

[Click here to create it](https://portal.basistheory.com/applications/create?type=private&permissions=3ds%3Asession%3Aauthenticate) with the following Permissions:

- Permissions: `3ds:session:authenticate`

<Alert>Save the API Key from the created Private Application as it will be used later in this guide.</Alert>

## Creating a Card Token

In order to run 3DS authentication on a customer card, it must be first tokenized with Basis Theory.
Follow the [Collect Cards Guide](/docs/guides/collect/collect-cards) to learn how to create a card token using a variety of different technologies available through the Basis Theory SDKs.

## Creating a 3DS Session

First, let's create a 3DS `session`, pass the created card token `id` as the `token_id` property and `merchant` as the session `type`.

<Tabs className="bt-tabs" queryString="backend">
<TabItem value="node" label="Node">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
//highlight-start
const { BasisTheoryClient, BasisTheory } = require("@basis-theory/node-sdk");
//highlight-end
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

//highlight-start
let bt;
(async () => {
  bt = await new BasisTheoryClient({ apiKey: "<PUBLIC_API_KEY>" });
})();
//highlight-end

//highlight-start
app.post("/sessions/create", async (req, res) => {
  const { token_id } = req.params;

  try {
    const session = await bt.threeds.sessions.create({
      tokenId: token_id,
      type: "merchant",
    });
    res.status(201).send(session);
  } catch (error) {
    console.error('Error while creating 3DS session:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>
<TabItem value="node-legacy" label="JavaScript (legacy)">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side-legacy/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
//highlight-start
const { BasisTheory } = require("@basis-theory/basis-theory-js");
//highlight-end
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

//highlight-start
let bt;
(async () => {
  bt = await new BasisTheory().init("<PUBLIC_API_KEY>");
})();
//highlight-end

//highlight-start
app.post("/sessions/create", async (req, res) => {
  const { token_id } = req.params;

  try {
    const session = await bt.threeds.createSession({
      tokenId: token_id,
      type: "merchant",
    });
    res.status(201).send(session);
  } catch (error) {
    console.error('Error while creating 3DS session:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>

<TabItem value="dotnet" label=".NET">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/dotnet) and [ASP.NET Core Framework](https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0).

```csharp showLineNumbers
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Threading.Tasks;

//highlight-start
using BasisTheory.Client;
using BasisTheory.Client.Threeds;
//highlight-end

namespace server.Controllers
{
    public class Program
    {
        public static void Main(string[] args)
        {
            WebHost.CreateDefaultBuilder(args)
              .UseUrls("http://0.0.0.0:4242")
              .UseWebRoot("public")
              .UseStartup<Startup>()
              .Build()
              .Run();
        }
    }

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddNewtonsoftJson();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment()) app.UseDeveloperExceptionPage();
            app.UseRouting();
            app.UseStaticFiles();
            app.UseEndpoints(endpoints => endpoints.MapControllers());
        }
    }

    //highlight-start
    [ApiController]
    public class ThreeDsApiController : ControllerBase
    {
        private readonly ThreeDSApi _client;

        public ThreeDsApiController()
        {
            _client = new BasisTheory.Client.BasisTheory(apiKey: "<PUBLIC_API_KEY>");
        }

        [HttpPost("session/create")]
        public async Task<ActionResult> CreateSession([FromBody] string tokenId)
        {
            var request = new CreateThreeDsSessionRequest()
            {
                TokenId = tokenId,
                Type = "merchant"
            };

            CreateThreeDsSessionResponse session = await _client.Threeds.Sessions.CreateAsync(request);

            if (session == null)
            {
                return BadRequest("Failed to create session.");
            }

            return StatusCode(201, response);
        }
    }
    //highlight-end
}
```
</TabItem>

<TabItem value="python" label="Python">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/python) and [Flask Framework](https://flask.palletsprojects.com/).

```python showLineNumbers
import os
from flask import Flask, request, jsonify

#highlight-start
from basis_theory import BasisTheory
#highlight-end

app = Flask(__name__)

#highlight-start
@app.route('/sessions/create', methods=['POST'])
def create_session():
  token_id = request.json.get('token_id')

  client = BasisTheory(
      api_key="<PUBLIC_API_KEY>",
  )

  session = client.threeds.sessions.create(
      token_id=token_id,
      type="merchant"
  )
  return jsonify(session.to_dict()), 201
#highlight-end

if __name__ == '__main__':
  app.run(port=4242, debug=True)
```
</TabItem>

<TabItem value="go" label="Go">
In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/go), [Go HTTP package](https://pkg.go.dev/net/http) and the [Gorilla Mux Router](https://github.com/gorilla/mux).

```go showLineNumbers
package main

import (
  "context"
  "encoding/json"
  "github.com/Basis-Theory/go-sdk/option"
  "github.com/Basis-Theory/go-sdk/threeds"
  "log"
  "net/http"
  // highlight-start
  basistheoryclient "github.com/Basis-Theory/go-sdk/client"
  // highlight-end
  "github.com/gorilla/mux"
)

func main() {
  router := mux.NewRouter()
  // highlight-start
  router.HandleFunc("/sessions/create", createSession).Methods("POST")
  // highlight-end
  addr := "localhost:4242"
  log.Printf("Listening on %s", addr)
  log.Fatal(http.ListenAndServe(addr, router))
}

func pointerToString(s string) *string {
  return &s
}

// highlight-start
func createSession(rw http.ResponseWriter, r *http.Request) {
  var request map[string]string
  json.NewDecoder(r.Body).Decode(&request)
  tokenId := request["token_id"]

  client := basistheoryclient.NewClient(
    option.WithAPIKey("<PUBLIC_API_KEY>"),
  )

  createThreeDSSessionRequest := &threeds.CreateThreeDsSessionRequest{
    TokenID: &tokenId, // Assigning the tokenId directly
    Type:    pointerToString("merchant"),
  }

  session, createErr := client.Threeds.Sessions.Create(context.Background(), createThreeDSSessionRequest)
  if createErr != nil {
    rw.WriteHeader(http.StatusInternalServerError)
    json.NewEncoder(rw).Encode(map[string]string{"error": createErr.Error()})
    return
  }

  rw.WriteHeader(http.StatusCreated)
  json.NewEncoder(rw).Encode(session)
}
//highlight-end
```
</TabItem>
</Tabs>

<Alert>Be sure to replace <code>&lt;PUBLIC_API_KEY></code> with the Public API Key you created in the <a href="#public-application">Public Application</a> step,
and pass <code>tokenId</code> to the call as the token id created in the <a href="#creating-a-card-token">Creating a Card Token</a> step.</Alert>

## Authenticating a 3DS Session

Once the `session` is created, it must be [authenticated](/docs/api/3ds/sessions#authenticate-session).
In this process, the merchant must send information about the transaction to the 3DS server.

This is done by calling [Authenticate 3DS Session](/docs/api/3ds/sessions#authenticate-session) endpoint from your own backend, with the private API key created earlier.

<Tabs className="bt-tabs" queryString="backend">
<TabItem value="node" label="Node">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
const { BasisTheoryClient, BasisTheory } = require("@basis-theory/node-sdk");
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

let bt;
// highlight-start
let btPrivate;
// highlight-end
(async () => {
  bt = await new BasisTheoryClient({ apiKey: "<PUBLIC_API_KEY>" });
  // highlight-start
  btPrivate = await new BasisTheoryClient({ apiKey: "<PRIVATE_API_KEY>" });
  // highlight-end
})();

app.post("/sessions/create", async (req, res) => {
  const { token_id } = req.params;

  try {
    const session = await bt.threeds.sessions.create({
      tokenId: token_id,
      type: "merchant",
    });
    res.status(201).send(session);
  } catch (error) {
    console.error('Error while creating 3DS session:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

//highlight-start
app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await btPrivate.threeds.sessions.authenticate(sessionId, {
        authenticationCategory: "payment",
        authenticationType: "other-payment",
        decoupledChallengeMaxTime: 10,
        purchaseInfo: {
          amount: "80000",
          currency: "826",
          exponent: "2",
          date: "20240109141010"
        },
        requestorInfo: {
          id: "example-3ds-merchant",
          name: "Example 3DS Merchant",
          url: "https://www.example.com/example-merchant"
        },
        merchantInfo: {
          mid: "9876543210001",
          acquirerBin: "000000999",
          name: "Example 3DS Merchant",
          categoryCode: "7922",
          countryCode: "826"
        },
        cardholderInfo: {
          name: "John Doe",
          email: "john@me.com"
        }
    });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```
</TabItem>
<TabItem value="node-legacy" label="JavaScript (legacy)">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side-legacy/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
const { BasisTheory } = require("@basis-theory/basis-theory-js");
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

let bt;
(async () => {
  bt = await new BasisTheory().init("<PUBLIC_API_KEY>");
})();

app.post("/sessions/create", async (req, res) => {
  const { token_id } = req.params;

  try {
    const session = await bt.threeds.createSession({
      tokenId: token_id,
      type: "merchant",
    });
    res.status(201).send(session);
  } catch (error) {
    console.error('Error while creating 3DS session:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

//highlight-start
app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await bt.threeds.authenticateSession(sessionId, {
      authenticationCategory: "payment",
      authenticationType: "other-payment",
      decoupledChallengeMaxTime: 10,
      purchaseInfo: {
        amount: "80000",
        currency: "826",
        exponent: "2",
        date: "20240109141010"
      },
      requestorInfo: {
        id: "example-3ds-merchant",
        name: "Example 3DS Merchant",
        url: "https://www.example.com/example-merchant"
      },
      merchantInfo: {
        mid: "9876543210001",
        acquirerBin: "000000999",
        name: "Example 3DS Merchant",
        categoryCode: "7922",
        countryCode: "826"
      },
      cardholderInfo: {
        name: "John Doe",
        email: "john@me.com"
      }
    }, { apiKey: "<PRIVATE_API_KEY>" });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>

<TabItem value="dotnet" label=".NET">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/dotnet) and [ASP.NET Core Framework](https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0).

```csharp showLineNumbers
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Threading.Tasks;

using BasisTheory.Client;
using BasisTheory.Client.Threeds;

namespace server.Controllers
{
    public class Program
    {
        public static void Main(string[] args)
        {
            WebHost.CreateDefaultBuilder(args)
              .UseUrls("http://0.0.0.0:4242")
              .UseWebRoot("public")
              .UseStartup<Startup>()
              .Build()
              .Run();
        }
    }

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddNewtonsoftJson();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment()) app.UseDeveloperExceptionPage();
            app.UseRouting();
            app.UseStaticFiles();
            app.UseEndpoints(endpoints => endpoints.MapControllers());
        }
    }

    [ApiController]
    public class ThreeDsApiController : ControllerBase
    {
        private readonly ThreeDSApi _client;

        public ThreeDsApiController()
        {
            _client = new BasisTheory.Client.BasisTheory(apiKey: "<PUBLIC_API_KEY>");
        }

        [HttpPost("session/create")]
        public async Task<ActionResult> CreateSession([FromBody] string tokenId)
        {
            var request = new CreateThreeDsSessionRequest()
            {
                TokenId = tokenId,
                Type = "merchant"
            };

            CreateThreeDsSessionResponse session = await _client.Threeds.Sessions.CreateAsync(request);

            if (session == null)
            {
                return BadRequest("Failed to create session.");
            }

            return StatusCode(201, response);
        }

        // highlight-start
        [HttpPost("{sessionId:guid}/authenticate")]
        public async Task<ActionResult> AuthenticateSession([FromRoute] Guid sessionId)
        {
            // authentication request requires private api key
            var client = new BasisTheory.Client.BasisTheory(apiKey: "<PRIVATE_API_KEY>");

            var request = new AuthenticateThreeDsSessionRequest()
            {
                AuthenticationCategory = "payment",
                AuthenticationType = "other-payment",
                DecoupledChallengeMaxTime = 10,
                PurchaseInfo = new ThreeDsPurchaseInfo
                {
                    Amount = "80000",
                    Currency = "826",
                    Exponent = "2",
                    Date = "20240109141010"
                },
                RequestorInfo = new ThreeDsRequestorInfo
                {
                    Id = "example-3ds-merchant",
                    Name = "Example 3DS Merchant",
                    Url = "https://www.example.com/example-merchant"
                },
                MerchantInfo = new ThreeDsMerchantInfo
                {
                    Mid = "9876543210001",
                    AcquirerBin = "000000999",
                    Name = "Example 3DS Merchant",
                    CategoryCode = "7922",
                    CountryCode = "826"
                },
                CardholderInfo = new ThreeDsCardholderInfo
                {
                    Name = "John Doe",
                    Email = "john@me.com"
                }
            };

            var authentication = await client.Threeds.Sessions.AuthenticateAsync(sessionId.ToString(), request);

            if (authentication == null)
            {
                return BadRequest("Failed to authenticate session.");
            }

            return Ok(authentication);
        }
        // highlight-end
    }
}
```
</TabItem>

<TabItem value="python" label="Python">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/python) and [Flask Framework](https://flask.palletsprojects.com/).

```python showLineNumbers
import os
from flask import Flask, request, jsonify

from basis_theory import BasisTheory, ThreeDsCardholderInfo, ThreeDsMerchantInfo, ThreeDsRequestorInfo, \
    ThreeDsPurchaseInfo

app = Flask(__name__)

@app.route('/sessions/create', methods=['POST'])
def create_session():
  token_id = request.json.get('token_id')

  client = BasisTheory(
      api_key="<PUBLIC_API_KEY>",
  )

  session = client.threeds.sessions.create(
      token_id=token_id,
      type="merchant"
  )
  return jsonify(session.to_dict()), 201

# highlight-start
@app.route('/<sessionId>/authenticate', methods=['POST'])
def authenticate_session(sessionId):
    client = BasisTheory(
        api_key="<PRIVATE_API_KEY>",
    )

    authentication = client.threeds.sessions.authenticate(
        sessionId=sessionId,
        authentication_category="payment",
        authentication_type="other-payment",
        decoupled_challenge_max_time=10,
        purchase_info=ThreeDsPurchaseInfo(
            amount="80000",
            currency="826",
            exponent="2",
            date="20240109141010"
        ),
        requestor_info=ThreeDsRequestorInfo(
            id="example-3ds-merchant",
            name="Example 3DS Merchant",
            url="https://www.example.com/example-merchant"
        ),
        merchant_info=ThreeDsMerchantInfo(
            mid="9876543210001",
            acquirer_bin="000000999",
            name="Example 3DS Merchant",
            category_code="7922",
            country_code="826"
        ),
        cardholder_info=ThreeDsCardholderInfo(
            name="John Doe",
            email="john@me.com"
        )
    )
    return jsonify(authentication.to_dict()), 200
# highlight-end

if __name__ == '__main__':
  app.run(port=4242, debug=True)
```
</TabItem>

<TabItem value="go" label="Go">
In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/go), [Go HTTP package](https://pkg.go.dev/net/http) and the [Gorilla Mux Router](https://github.com/gorilla/mux).

```go showLineNumbers
package main

import (
  "context"
  "encoding/json"
  "github.com/Basis-Theory/go-sdk/option"
  "github.com/Basis-Theory/go-sdk/threeds"
  "log"
  "net/http"
  basistheoryclient "github.com/Basis-Theory/go-sdk/client"
  "github.com/gorilla/mux"
)

func main() {
  router := mux.NewRouter()
  router.HandleFunc("/sessions/create", createSession).Methods("POST")
  // highlight-start
  router.HandleFunc("/{sessionId}/authenticate", authenticateSession).Methods("POST")
  //highlight-end
  addr := "localhost:4242"
  log.Printf("Listening on %s", addr)
  log.Fatal(http.ListenAndServe(addr, router))
}

func pointerToString(s string) *string {
  return &s
}

func createSession(rw http.ResponseWriter, r *http.Request) {
  var request map[string]string
  json.NewDecoder(r.Body).Decode(&request)
  tokenId := request["token_id"]

  client := basistheoryclient.NewClient(
    option.WithAPIKey("<PUBLIC_API_KEY>"),
  )

  createThreeDSSessionRequest := &threeds.CreateThreeDsSessionRequest{
    TokenID: &tokenId, // Assigning the tokenId directly
    Type:    pointerToString("merchant"),
  }

  session, createErr := client.Threeds.Sessions.Create(context.Background(), createThreeDSSessionRequest)
  if createErr != nil {
    rw.WriteHeader(http.StatusInternalServerError)
    json.NewEncoder(rw).Encode(map[string]string{"error": createErr.Error()})
    return
  }

  rw.WriteHeader(http.StatusCreated)
  json.NewEncoder(rw).Encode(session)
}

// highlight-start
func authenticateSession(rw http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	sessionId := vars["sessionId"]

	client := basistheoryclient.NewClient(
		option.WithAPIKey("<PRIVATE_API_KEY>"),
	)

	authenticateThreeDSSessionRequest := threeds.AuthenticateThreeDsSessionRequest{
		AuthenticationCategory: "payment",
		AuthenticationType:     "payment-transaction",
		PurchaseInfo: &basistheory.ThreeDsPurchaseInfo{
			Amount:   pointerToString("80000"),
			Currency: pointerToString("826"),
			Exponent: pointerToString("2"),
			Date:     pointerToString("20240109141010"),
		},
		RequestorInfo: &basistheory.ThreeDsRequestorInfo{
			ID:   pointerToString("example-3ds-merchant"),
			Name: pointerToString("Example 3DS Merchant"),
			URL:  pointerToString("https://www.example.com/example-merchant"),
		},
		MerchantInfo: &basistheory.ThreeDsMerchantInfo{
			Mid:         pointerToString("9876543210001"),
			AcquirerBin: pointerToString("000000999"),
			Name:        pointerToString("Example 3DS Merchant"),
			CategoryCode:pointerToString("7922"),
			CountryCode: pointerToString("826"),
		},
		CardholderInfo: &basistheory.ThreeDsCardholderInfo{
			Name:  pointerToString("John Doe"),
			Email: pointerToString("john@me.com"),
		},
	}

	authenticateResponse, authenticateErr := client.Threeds.Sessions.Authenticate(context.Background(), sessionId, &authenticateThreeDSSessionRequest)

	if authenticateErr != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(rw).Encode(map[string]string{"error": authenticateErr.Error()})
		return
	}

	rw.WriteHeader(http.StatusOK)
	json.NewEncoder(rw).Encode(authenticateResponse)
}
// highlight-end
```
</TabItem>
</Tabs>

<Alert type={Alerts.WARNING}>On a production environment, your endpoint to authorize sessions should be behind your own authorization scheme.</Alert>

<Alert>Be sure to replace <code>&lt;PRIVATE_API_KEY></code> with the Private API Key you created previously.</Alert>

If the `status` for the authentication response is `successful`, that means a frictionless authentication happened and the authentication token is available as the `authentication_value` property.

## Decoupled Challenge

If after authenticating a 3DS session, the authentication response `status` is set as `decoupled-challenge`, that means that a decoupled challenge is necessary before getting the final 3DS authentication value.

A 3DS decoupled challenge is an authentication method where the cardholder verifies their identity (solves a challenge) separately from the transaction flow—often on a different device or at a different time.

You can specify a time limit for the decoupled challenge to be completed by setting the `decoupled_challenge_max_time` property in the authentication request.

### Verifying Decoupled Challenge Completion

Since the decoupled challenge is handled by the card issuer, you must create a [Webhook](/docs/api/webhooks/) to receive a notification when the challenge is completed.

Check our [official documentation](/docs/api/webhooks/api) on all the different manners you can create a Webhook with Basis Theory.

For the 3DS decoupled challenge, you should create a Webhook that looks for the `3ds.session.decoupled-challenge-notification` [event type](/docs/api/webhooks/eventdata#decoupled-challenge-notification).

## Retrieving a Challenge Result

Once a challenge is complete and a decoupled challenge notification is received, results are retrieved by calling the [Get Challenge Result](/docs/api/3ds/sessions#get-challenge-result) endpoint from your backend.

This is done by calling the Basis Theory backend endpoint `/3ds/{sessionId}/sessions/challenge-result`  from your own backend, using the same private API key that was used to authenticate.

<Tabs className="bt-tabs" queryString="backend">
<TabItem value="node" label="Node">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
const { BasisTheory } = require("@basis-theory/basis-theory-js");
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

let bt;
(async () => {
  bt = await new BasisTheory().init("<PUBLIC_API_KEY>");
})();

app.post("/sessions/create", async (req, res) => {
  const { token_id } = req.params;

  try {
    const session = await bt.threeds.createSession({
      tokenId: token_id,
      type: "merchant",
    });
    res.status(201).send(session);
  } catch (error) {
    console.error('Error while creating 3DS session:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await bt.threeds.authenticateSession(sessionId, {
      authenticationCategory: "payment",
      authenticationType: "other-payment",
      decoupledChallengeMaxTime: 10,
      purchaseInfo: {
        amount: "80000",
        currency: "826",
        exponent: "2",
        date: "20240109141010"
      },
      requestorInfo: {
        id: "example-3ds-merchant",
        name: "Example 3DS Merchant",
        url: "https://www.example.com/example-merchant"
      },
      merchantInfo: {
        mid: "9876543210001",
        acquirerBin: "000000999",
        name: "Example 3DS Merchant",
        categoryCode: "7922",
        countryCode: "826"
      },
      cardholderInfo: {
        name: "John Doe",
        email: "john@me.com"
      }
    }, { apiKey: "<PRIVATE_API_KEY>" });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

//highlight-start
app.get("/:sessionId/challenge-result", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const result = await btPrivate.threeds.sessions.getChallengeResult(sessionId);
    res.status(200).send(result);
  } catch (error) {
    console.error('Error getting challenge result:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>
<TabItem value="node-legacy" label="JavaScript (legacy)">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side-legacy/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
const { BasisTheory } = require("@basis-theory/basis-theory-js");
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

let bt;
(async () => {
  bt = await new BasisTheory().init("<PUBLIC_API_KEY>");
})();

app.post("/sessions/create", async (req, res) => {
  const { token_id } = req.params;

  try {
    const session = await bt.threeds.createSession({
      tokenId: token_id,
      type: "merchant",
    });
    res.status(201).send(session);
  } catch (error) {
    console.error('Error while creating 3DS session:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await bt.threeds.authenticateSession(sessionId, {
      authenticationCategory: "payment",
      authenticationType: "other-payment",
      decoupledChallengeMaxTime: 10,
      purchaseInfo: {
        amount: "80000",
        currency: "826",
        exponent: "2",
        date: "20240109141010"
      },
      requestorInfo: {
        id: "example-3ds-merchant",
        name: "Example 3DS Merchant",
        url: "https://www.example.com/example-merchant"
      },
      merchantInfo: {
        mid: "9876543210001",
        acquirerBin: "000000999",
        name: "Example 3DS Merchant",
        categoryCode: "7922",
        countryCode: "826"
      },
      cardholderInfo: {
        name: "John Doe",
        email: "john@me.com"
      }
    }, { apiKey: "<PRIVATE_API_KEY>" });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

//highlight-start
app.get("/:sessionId/challenge-result", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const result = await bt.threeds.getChallengeResult(sessionId, { apiKey: "<PRIVATE_API_KEY>" });
    res.status(200).send(result);
  } catch (error) {
    console.error('Error getting challenge result:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>

<TabItem value="dotnet" label=".NET">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/dotnet) and [ASP.NET Core Framework](https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0).

```csharp showLineNumbers
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Threading.Tasks;

using BasisTheory.Client;
using BasisTheory.Client.Threeds;

namespace server.Controllers
{
    public class Program
    {
        public static void Main(string[] args)
        {
            WebHost.CreateDefaultBuilder(args)
              .UseUrls("http://0.0.0.0:4242")
              .UseWebRoot("public")
              .UseStartup<Startup>()
              .Build()
              .Run();
        }
    }

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddNewtonsoftJson();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment()) app.UseDeveloperExceptionPage();
            app.UseRouting();
            app.UseStaticFiles();
            app.UseEndpoints(endpoints => endpoints.MapControllers());
        }
    }

    [ApiController]
    public class ThreeDsApiController : ControllerBase
    {
        private readonly ThreeDSApi _client;

        public ThreeDsApiController()
        {
            _client = new BasisTheory.Client.BasisTheory(apiKey: "<PUBLIC_API_KEY>");
        }

        [HttpPost("session/create")]
        public async Task<ActionResult> CreateSession([FromBody] string tokenId)
        {
            var request = new CreateThreeDsSessionRequest()
            {
                TokenId = tokenId,
                Type = "merchant"
            };

            CreateThreeDsSessionResponse session = await _client.Threeds.Sessions.CreateAsync(request);

            if (session == null)
            {
                return BadRequest("Failed to create session.");
            }

            return StatusCode(201, response);
        }

        [HttpPost("{sessionId:guid}/authenticate")]
        public async Task<ActionResult> AuthenticateSession([FromRoute] Guid sessionId)
        {
            // authentication request requires private api key
            var client = new BasisTheory.Client.BasisTheory(apiKey: "<PRIVATE_API_KEY>");

            var request = new AuthenticateThreeDsSessionRequest()
            {
                AuthenticationCategory = "payment",
                AuthenticationType = "other-payment",
                DecoupledChallengeMaxTime = 10,
                PurchaseInfo = new ThreeDsPurchaseInfo
                {
                    Amount = "80000",
                    Currency = "826",
                    Exponent = "2",
                    Date = "20240109141010"
                },
                RequestorInfo = new ThreeDsRequestorInfo
                {
                    Id = "example-3ds-merchant",
                    Name = "Example 3DS Merchant",
                    Url = "https://www.example.com/example-merchant"
                },
                MerchantInfo = new ThreeDsMerchantInfo
                {
                    Mid = "9876543210001",
                    AcquirerBin = "000000999",
                    Name = "Example 3DS Merchant",
                    CategoryCode = "7922",
                    CountryCode = "826"
                },
                CardholderInfo = new ThreeDsCardholderInfo
                {
                    Name = "John Doe",
                    Email = "john@me.com"
                }
            };

            var authentication = await client.Threeds.Sessions.AuthenticateAsync(sessionId.ToString(), request);

            if (authentication == null)
            {
                return BadRequest("Failed to authenticate session.");
            }

            return Ok(authentication);
        }

        // highlight-start
        [HttpGet("{sessionId:guid}/challenge-result")]
        public async Task<ActionResult> GetChallengeResult([FromRoute] Guid sessionId)
        {
            // challenge result request requires private api key
            var client = new BasisTheory.Client.BasisTheory(apiKey: "<PRIVATE_API_KEY>");

            var result = await client.Threeds.Sessions.GetChallengeResultAsync(sessionId);

            if (result == null)
            {
                return BadRequest("Failed to get challenge result.");
            }

            return Ok(result);
        }
        // highlight-end
    }
}
```
</TabItem>

<TabItem value="python" label="Python">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/python) and [Flask Framework](https://flask.palletsprojects.com/).

```python showLineNumbers
import os
from flask import Flask, request, jsonify

from basis_theory import BasisTheory, ThreeDsCardholderInfo, ThreeDsMerchantInfo, ThreeDsRequestorInfo, \
    ThreeDsPurchaseInfo

app = Flask(__name__)

@app.route('/sessions/create', methods=['POST'])
def create_session():
  token_id = request.json.get('token_id')

  client = BasisTheory(
      api_key="<PUBLIC_API_KEY>",
  )

  session = client.threeds.sessions.create(
      token_id=token_id,
      type="merchant"
  )
  return jsonify(session.to_dict()), 201


@app.route('/<sessionId>/authenticate', methods=['POST'])
def authenticate_session(sessionId):
    client = BasisTheory(
        api_key="<PRIVATE_API_KEY>",
    )

    authentication = client.threeds.sessions.authenticate(
        sessionId=sessionId,
        authentication_category="payment",
        authentication_type="other-payment",
        decoupled_challenge_max_time=10,
        purchase_info=ThreeDsPurchaseInfo(
            amount="80000",
            currency="826",
            exponent="2",
            date="20240109141010"
        ),
        requestor_info=ThreeDsRequestorInfo(
            id="example-3ds-merchant",
            name="Example 3DS Merchant",
            url="https://www.example.com/example-merchant"
        ),
        merchant_info=ThreeDsMerchantInfo(
            mid="9876543210001",
            acquirer_bin="000000999",
            name="Example 3DS Merchant",
            category_code="7922",
            country_code="826"
        ),
        cardholder_info=ThreeDsCardholderInfo(
            name="John Doe",
            email="john@me.com"
        )
    )
    return jsonify(authentication.to_dict()), 200

# highlight-start
@app.route('/<sessionId>/challenge-result', methods=['GET'])
def get_challenge_result(sessionId):
    client = BasisTheory(
        api_key="<PRIVATE_API_KEY>",
    )

    result = client.threeds.sessions.challenge_result(sessionId=sessionId)
# highlight-end

if __name__ == '__main__':
  app.run(port=4242, debug=True)
```
</TabItem>

<TabItem value="go" label="Go">
In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/go), [Go HTTP package](https://pkg.go.dev/net/http) and the [Gorilla Mux Router](https://github.com/gorilla/mux).

```go showLineNumbers
package main

import (
  "context"
  "encoding/json"
  "github.com/Basis-Theory/go-sdk/option"
  "github.com/Basis-Theory/go-sdk/threeds"
  "log"
  "net/http"
  basistheoryclient "github.com/Basis-Theory/go-sdk/client"
  "github.com/gorilla/mux"
)

func main() {
  router := mux.NewRouter()
  router.HandleFunc("/sessions/create", createSession).Methods("POST")
  router.HandleFunc("/{sessionId}/authenticate", authenticateSession).Methods("POST")
  // highlight-start
  router.HandleFunc("/{sessionId}/challenge-result", getChallengeResult).Methods("GET")
  //highlight-end
  addr := "localhost:4242"
  log.Printf("Listening on %s", addr)
  log.Fatal(http.ListenAndServe(addr, router))
}

func pointerToString(s string) *string {
  return &s
}

func createSession(rw http.ResponseWriter, r *http.Request) {
  var request map[string]string
  json.NewDecoder(r.Body).Decode(&request)
  tokenId := request["token_id"]

  client := basistheoryclient.NewClient(
    option.WithAPIKey("<PUBLIC_API_KEY>"),
  )

  createThreeDSSessionRequest := &threeds.CreateThreeDsSessionRequest{
    TokenID: &tokenId, // Assigning the tokenId directly
    Type:    pointerToString("merchant"),
  }

  session, createErr := client.Threeds.Sessions.Create(context.Background(), createThreeDSSessionRequest)
  if createErr != nil {
    rw.WriteHeader(http.StatusInternalServerError)
    json.NewEncoder(rw).Encode(map[string]string{"error": createErr.Error()})
    return
  }

  rw.WriteHeader(http.StatusCreated)
  json.NewEncoder(rw).Encode(session)
}

func authenticateSession(rw http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	sessionId := vars["sessionId"]

	client := basistheoryclient.NewClient(
		option.WithAPIKey("<PRIVATE_API_KEY>"),
	)

	authenticateThreeDSSessionRequest := threeds.AuthenticateThreeDsSessionRequest{
		AuthenticationCategory: "payment",
		AuthenticationType:     "payment-transaction",
		PurchaseInfo: &basistheory.ThreeDsPurchaseInfo{
			Amount:   pointerToString("80000"),
			Currency: pointerToString("826"),
			Exponent: pointerToString("2"),
			Date:     pointerToString("20240109141010"),
		},
		RequestorInfo: &basistheory.ThreeDsRequestorInfo{
			ID:   pointerToString("example-3ds-merchant"),
			Name: pointerToString("Example 3DS Merchant"),
			URL:  pointerToString("https://www.example.com/example-merchant"),
		},
		MerchantInfo: &basistheory.ThreeDsMerchantInfo{
			Mid:         pointerToString("9876543210001"),
			AcquirerBin: pointerToString("000000999"),
			Name:        pointerToString("Example 3DS Merchant"),
			CategoryCode:pointerToString("7922"),
			CountryCode: pointerToString("826"),
		},
		CardholderInfo: &basistheory.ThreeDsCardholderInfo{
			Name:  pointerToString("John Doe"),
			Email: pointerToString("john@me.com"),
		},
	}

	authenticateResponse, authenticateErr := client.Threeds.Sessions.Authenticate(context.Background(), sessionId, &authenticateThreeDSSessionRequest)

	if authenticateErr != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(rw).Encode(map[string]string{"error": authenticateErr.Error()})
		return
	}

	rw.WriteHeader(http.StatusOK)
	json.NewEncoder(rw).Encode(authenticateResponse)
}

// highlight-start
func getChallengeResult(rw http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	sessionId := vars["sessionId"]

	client := basistheoryclient.NewClient(
		option.WithAPIKey("<PRIVATE_API_KEY>"),
	)

	challengeResult, err := client.Threeds.Sessions.GetChallengeResult(context.Background(), sessionId)
	if err != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(rw).Encode(map[string]string{"error": err.Error()})
		return
	}

	rw.WriteHeader(http.StatusOK)
	json.NewEncoder(rw).Encode(challengeResult)
}
// highlight-end
```
</TabItem>
</Tabs>

That's it 🎉!
The result from the `authentication` (in case of frictionless) or `challenge-result` calls contains the authentication token (`authentication_value` attribute) and any other information needed to fully process the 3DS transaction.

## Learn More

- [3DS API Reference](/docs/api/3ds/sessions)
