---
toc_max_heading_level: 2
---

import { Alert, Alerts } from "@site/src/components/shared/Alert";
import JavaScript from "@site/static/img/sdk/logos/javascript.svg";
import Android from "@site/static/img/sdk/logos/android.svg";
import AppleDark from "@site/static/img/sdk/logos/apple-dark.svg";
import Apple from "@site/static/img/sdk/logos/apple.svg";
import React from "@site/static/img/sdk/logos/react.svg";
import { Card } from "@site/src/components/shared/Card";
import styles from "@site/src/pages/index.module.css";
import GettingStartedSection from "@site/src/components/docs/_getting-started-section.mdx";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ThemedImage from "@theme/ThemedImage";
import useBaseUrl from "@docusaurus/useBaseUrl";

# Authenticate with 3DS

[3DS (3D Secure)](/docs/features/3d-secure) is an online payment authentication protocol that enhances anti-fraud efforts. It requires cardholders to undergo an additional layer of verification, such as a one-time password or biometric scan, during online transactions.
It is also the most common implementation of Secure Customer Authentication (SCA) for regulations such as PSD2.

In this guide, we will set up the Basis Theory 3DS package to start a 3DS Customer Initiated Transaction (CIT) in a frontend web application, and securely authenticate it using the Basis Theory Platform.
If you are looking to authenticate a Merchant Initiated Transaction (MIT), please refer to the [MIT Guide](/docs/guides/process/authenticate-mit-with-3ds).

<Alert type={Alerts.INFO}>3D Secure is an Enterprise feature. Contact <a href="mailto:support@basistheory.com">support@basistheory.com</a> to request access.</Alert>

## Going Live Prerequisites
<Alert> These steps are only required if you are going to use the Basis Theory 3DS SDKs in a production environment. These steps can take lead time to complete - if you plan to use Basis Theory 3DS, it is wise to start these steps as soon as possible.</Alert>

A few requirements are needed before you can start using the Basis Theory 3DS SDKs in a production environment:

1. You must get your the MID for each Network(Visa, Mastercard, etc.) you plan to use with Basis Theory 3DS - your current primary processor will provide these.
1.1 You will need to reach out to your Account Representative or Support to get these.
2. You need to ensure your Processor is capable of accepting 3DS authentication values from a 3rd party 3DS provider.
3. Map the 3DS authentication values Basis Theory provides to your Processor's 3DS authentication values.

## Getting Started

<GettingStartedSection />

## Provisioning Resources

In this section, we will explore the bare minimum resources necessary to authenticate with 3DS.

### Public Application

You will need a [Public Application](/docs/api/applications) with permissions to create tokens and 3DS sessions. [Click here to create one](https://portal.basistheory.com/applications/create?permissions=token%3Acreate&permissions=3ds%3Asession%3Acreate&type=public).

This will create an application with the following Permissions:
* Permissions: `token:create`, `3ds:session:create`

<Alert>Save the API Key from the created Public Application as it will be used later in this guide.</Alert>

### Private Application

Next, you will need a [Private Application](/docs/api/applications) for your backend with the permission to authenticate 3DS sessions.

[Click here to create it](https://portal.basistheory.com/applications/create?type=private&permissions=3ds%3Asession%3Aauthenticate) with the following Permissions:

- Permissions: `3ds:session:authenticate`

<Alert>Save the API Key from the created Private Application as it will be used later in this guide.</Alert>

## Configuring the Basis Theory 3DS SDK

The 3DS SDK is available as an NPM package for Web and React Native, and also available for Android and iOS apps.

See instructions below on how to install and configure it.
<div className={styles["sdk-column"]}>
  <Card
    href="/docs/sdks/web/3ds/"
    img={<JavaScript />}
    className={styles.sdk}
  >Web 3DS SDK Reference</Card>

  <Card
    href="/docs/sdks/mobile/3ds"
    img={<Android />}
    className={styles.sdk}
  >Android 3DS SDK Reference</Card>

  <Card
    href="/docs/sdks/mobile/3ds"
    img={<div className={styles["logo-container"]}><ThemedImage
           width="100%"
           height="100%"
           sources={{
              light: useBaseUrl("/img/sdk/logos/apple.svg"),
              dark: useBaseUrl("/img/sdk/logos/apple-dark.svg"),
            }}
        />
      </div>}
  className={styles.sdk}>iOS 3DS SDK Reference</Card>

  <Card
    href="/docs/sdks/mobile/react-native-threeds/"
    img={<React />}
    className={styles.sdk}
  >React Native SDK Reference</Card>
  </div>

## Creating a Card Token

In order to run 3DS authentication on a customer card, it must be first tokenized with Basis Theory.
Follow the [Collect Cards Guide](/docs/guides/collect/collect-cards) to learn how to create a card token using a variety of different technologies available through the Basis Theory SDKs.

Every Card Token contains a [`card` details object](/docs/api/tokens/#card-details) that we can leverage to conditionally trigger the 3DS flow. For example:

```javascript
if (token.card.authentication === 'sca_required') {
  // start 3DS flow
} else {
  // may skip 3DS because it is not mandatory for the card's BIN range
}
```

## Creating a Session and Device Fingerprinting

The 3D Secure process starts with identifying certain information about the customer's device to aid in verifying if the transaction is valid.
The Basis Theory 3DS SDK takes care of that process, collecting all necessary information and sending that over to the 3D secure server for processing.


First, let's create a 3DS `session` and pass the created card token `id` as the `pan` property.
The SDK will then collect the device info as previously described, and send it alongside the de-tokenized card number (pan) to the 3DS server in order to initiate a 3DS transaction.

<Tabs className="bt-tabs" queryString="frontend">
  <TabItem value="ts" label="Web">
```typescript showLineNumbers
import { BasisTheory3ds } from "@basis-theory/web-threeds";

const checkout = async () => {
  // initializing the 3ds sdk
  const bt3ds = BasisTheory3ds("<PUBLIC_API_KEY>");

  //highlight-start
  // creating the session
  const session = await bt3ds.createSession({ pan: "<CARD_TOKEN_ID>" });
  //highlight-end
}
```
  </TabItem>

  <TabItem value="ios" label="iOS">
```swift showLineNumbers
class ViewController: UIViewController {
    private var threeDSService: ThreeDSService! // important to keep `threeDSService` outside of the Task, otherwise swift will handle it as a weak reference and you may experience undesired behavior
    let customHeaders: [String: String] = [
          "Authorization": "Bearer your_token_here",
          "Trace-Id": "your_trace_id_here"
      ]

    override func viewDidLoad() {
        super.viewDidLoad()

        Task {
            do {
                threeDSService = try ThreeDSService.builder()
                    .withApiKey("<PUBLIC_API_KEY>")
                    .withAuthenticationEndpoint("<YOUR AUTHENTICATION ENDPOINT>", customHeaders)
                    .build()

                try await threeDSService.initialize { [weak self] warnings in
                        if let warnings = warnings, !warnings.isEmpty {
                            let messages = warnings.map { $0.message }.joined(separator: "\n")

                            print(messages)
                        } else {
                            print("No warnings.")
                        }
                }
                //highlight-start
                // creating the session
                let session = try await threeDSService.createSession(tokenId: "<CARD TOKEN ID>")
                //highlight-end
            } catch {
                print(error.localizedDescription)
            }
        }
    }
}
```
  </TabItem>

  <TabItem value="android" label="Android">
```kotlin showLineNumbers
val customHeaders = Headers.Builder()
        .add("Authorization", "Bearer your_token_here")
        .add("Trace-Id", "your_trace_id_here")
        .build();

val threeDSService = ThreeDsService.Builder()
  .withApiKey("<PUBLIC_API_KEY>")
  .withApplicationContext(context)
  .withAuthenticationEndpoint("Your 3DS authentication endpoint URL", customHeaders) // https://developers.basistheory.com/docs/guides/process/authenticate-with-3ds#authenticating-a-session
  .apply {
      // make sure withSandbox is removed in production environments
      if (BuildConfig.DEBUG) {
        withSandbox()
      }
  }
  .build()

val warnings = threeDSService.initialize()

if (!warnings.isNullOrEmpty()) {
  // inspect warnings
}

//highlight-start
// creating the session
val session = threeDSService.createSession("<CARD_TOKEN_ID>")
//highlight-end
```
  </TabItem>

  <TabItem value="react" label="React Native">
```jsx showLineNumbers
import { BasisTheory3dsProvider, useBasisTheory3ds } from "@basis-theory/react-native-threeds";

const App = () => {
  return (
    <BasisTheory3dsProvider apiKey={"<PUBLIC_API_KEY>"}>
      <MyApp />
    </BasisTheory3dsProvider>
  );
}

const MyApp = () => {
  const { createSession, startChallenge } = useBasisTheory3ds();

  //highlight-start
  //creating the session
  const session = await createSession({ tokenId: "<CARD_TOKEN_ID>" });
  //highlight-end
}
```
  </TabItem>
</Tabs>

<Alert>Be sure to replace <code>&lt;PUBLIC_API_KEY></code> with the Public API Key you created in the <a href="#public-application">Public Application</a> step,
and <code>&lt;CARD_TOKEN_ID></code> with the token id created in the <a href="#creating-a-card-token">Creating a Card Token</a> step.</Alert>

## Authenticating a Session

<Alert>
There are many optional values that can be sent to the 3DS server. Basis Theory suggests you send as many as possible to increase chances of a frictionless authentication. The lack of any of these values will not prevent the authentication from happening, but the more information you can provide, the better chances of a frictionless challenge to be approved.
</Alert>

Once the `session` is created, it must be [authenticated](/docs/api/3ds/sessions#authenticate-session).
In this process, the merchant or requestor must send information about the transaction to the 3DS server.

This is done by calling [Authenticate 3DS Session](/docs/api/3ds/sessions#authenticate-session) endpoint from your own backend, with the private API key created earlier.

One important note is the usage of [authenticationCategory](/docs/api/3ds/sessions#authentication-categories). The two values you can choose from are `payment` and `non-payment`, in nearly every use-case you will want to utilzie `payment`:

| Authentication Category | Description                                                                                          |
|-------------------------|------------------------------------------------------------------------------------------------------|
| `payment`               | Used if you plan to ever charge the card                                                             |
| `non-payment`           | Used if you do not plan to charge the card, and are only adding the card for authentication purposes |


<Tabs className="bt-tabs" queryString="backend">
<TabItem value="node" label="Node">
In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/node) and [Express framework](https://expressjs.com/) for Node.js.
```javascript showLineNumbers
//highlight-start
const { BasisTheoryClient, BasisTheory } = require("@basis-theory/node-sdk")
//highlight-end
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

//highlight-start
let bt;
(async () => {
  bt = await new BasisTheoryClient({ apiKey: "<API_KEY>" });
})();
//highlight-end

//highlight-start
app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await bt.threeds.sessions.authenticate(sessionId, {
       authenticationCategory: "payment",
       authenticationType: "payment-transaction",
       purchaseInfo: {
           amount: "80000",
           currency: "826",
           exponent: "2",
           date: "20240109141010"
       },
       requestorInfo: {
           id: "example-3ds-merchant",
           name: "Example 3DS Merchant",
           url: "https://www.example.com/example-merchant"
       },
       merchantInfo: {
           mid: "9876543210001",
           acquirerBin: "000000999",
           name: "Example 3DS Merchant",
           categoryCode: "7922",
           countryCode: "826"
       },
       cardholderInfo: {
           name: "John Doe",
           email: "john@me.com"
       }
    });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>
<TabItem value="node-legacy" label="JavaScript (legacy)">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/javascript-legacy) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
//highlight-start
const { BasisTheory } = require("@basis-theory/basis-theory-js");
//highlight-end
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

//highlight-start
let bt;
(async () => {
  bt = await new BasisTheory().init("<API_KEY>");
})();
//highlight-end

//highlight-start
app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await bt.threeds.authenticateSession(sessionId, {
      authenticationCategory: "payment",
      authenticationType: "payment-transaction",
      purchaseInfo: {
        amount: "80000",
        currency: "826",
        exponent: "2",
        date: "20240109141010"
      },
      requestorInfo: {
        id: "example-3ds-merchant",
        name: "Example 3DS Merchant",
        url: "https://www.example.com/example-merchant"
      },
      merchantInfo: {
        mid: "9876543210001",
        acquirerBin: "000000999",
        name: "Example 3DS Merchant",
        categoryCode: "7922",
        countryCode: "826"
      },
      cardholderInfo: {
        name: "John Doe",
        email: "john@me.com"
      }
    });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

```
</TabItem>

<TabItem value="dotnet" label=".NET">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/dotnet) and [ASP.NET Core Framework](https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0).

```csharp showLineNumbers
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Threading.Tasks;

//highlight-start
using BasisTheory.Client;
using BasisTheory.Client.Threeds;
//highlight-end

namespace server.Controllers
{
  public class Program
  {
    public static void Main(string[] args)
    {
      WebHost.CreateDefaultBuilder(args)
        .UseUrls("http://0.0.0.0:4242")
        .UseWebRoot("public")
        .UseStartup<Startup>()
        .Build()
        .Run();
    }
  }

  public class Startup
  {
    public void ConfigureServices(IServiceCollection services)
    {
      services.AddMvc().AddNewtonsoftJson();
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
      if (env.IsDevelopment()) app.UseDeveloperExceptionPage();
      app.UseRouting();
      app.UseStaticFiles();
      app.UseEndpoints(endpoints => endpoints.MapControllers());
    }
  }

  //highlight-start
  [ApiController]
  public class ThreeDsApiController : Controller
  {
    private readonly ThreeDSClient _client;

    public ThreeDsApiController()
    {
      _client = new BasisTheory(apiKey: "<PRIVATE_API_KEY>");
    }

    [HttpPost("{sessionId:guid}/authenticate")]
    public async Task<ActionResult> AuthenticateSession([FromRoute] Guid sessionId)
    {
      var authentication = await _client.Threeds.Sessions.AuthenticateAsync(sessionId.ToString(), new AuthenticateThreeDsSessionRequest
      {
        AuthenticationCategory = "payment",
        AuthenticationType = "payment-transaction",
        PurchaseInfo = new ThreeDsPurchaseInfo
        {
          Amount = "80000",
          Currency = "826",
          Exponent = "2",
          Date = "20240109141010"
        },
        RequestorInfo = new ThreeDsRequestorInfo
        {
          Id = "example-3ds-merchant",
          Name = "Example 3DS Merchant",
          Url = "https://www.example.com/example-merchant"
        },
        MerchantInfo = new ThreeDsMerchantInfo
        {
          Mid = "9876543210001",
          AcquirerBin = "000000999",
          Name = "Example 3DS Merchant",
          CategoryCode = "7922",
          CountryCode = "826"
        },
        CardholderInfo = new ThreeDsCardholderInfo
        {
          Name = "John Doe",
          Email = "john@me.com"
        }
      });

      if (authentication == null)
      {
        return BadRequest("Failed to authenticate session.");
      }

      return Ok(authentication);
    }
  }
  //highlight-end
}
```
</TabItem>

<TabItem value="python" label="Python">

In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/python) and [Flask Framework](https://flask.palletsprojects.com/).

```python showLineNumbers
import os
from flask import Flask, request, jsonify

#highlight-start
from basis_theory import BasisTheory, ThreeDsPurchaseInfo, \
    ThreeDsRequestorInfo, ThreeDsMerchantInfo, ThreeDsCardholderInfo
#highlight-end

app = Flask(__name__)

#highlight-start
@app.route('/<sessionId>/authenticate', methods=['POST'])
def authenticate_session(sessionId):
  client = BasisTheory(
    api_key="<PRIVATE_API_KEY>",
  )

  authentication = client.threeds.sessions.authorize(
      session_id="",
      authentication_category="payment",
      authentication_type="payment-transaction",
      purchase_info=ThreeDsPurchaseInfo(
          amount="80000",
          currency="826",
          exponent="2",
          date="20240109141010"
      ),
      requestor_info=ThreeDsRequestorInfo(
          id="example-3ds-merchant",
          name="Example 3DS Merchant",
          url="https://www.example.com/example-merchant"
      ),
      merchant_info=ThreeDsMerchantInfo(
          mid="9876543210001",
          acquirer_bin="000000999",
          name="Example 3DS Merchant",
          category_code="7922",
          country_code="826"
      ),
      cardholder_info=ThreeDsCardholderInfo(
          name="John Doe",
          email="john@me.com"
      )
  )
  return jsonify(authentication.to_dict()), 200
  #highlight-end

if __name__ == '__main__':
  app.run(port=4242, debug=True)
```
</TabItem>

<TabItem value="go" label="Go">
In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/go), [Go HTTP package](https://pkg.go.dev/net/http) and the [Gorilla Mux Router](https://github.com/gorilla/mux).

```go showLineNumbers
package main

import (
	"context"
	"encoding/json"
	// highlight-start
	basistheory "github.com/Basis-Theory/go-sdk"
	basistheoryclient "github.com/Basis-Theory/go-sdk/client"
	"github.com/Basis-Theory/go-sdk/option"
	"github.com/Basis-Theory/go-sdk/threeds"
	// highlight-end
	"github.com/gorilla/mux"
	"log"
	"net/http"
)


func main() {
	router := mux.NewRouter()
	router.HandleFunc("/{sessionId}/authenticate", authenticateSession).Methods("POST")
	addr := "localhost:4242"
	log.Printf("Listening on %s", addr)
	log.Fatal(http.ListenAndServe(addr, router))
}

func pointerToString(s string) *string {
	return &s
}

// highlight-start
func authenticateSession(rw http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	sessionId := vars["sessionId"]

	client := basistheoryclient.NewClient(
		option.WithAPIKey("<API_KEY>"),
	)

	authRequest := &threeds.AuthenticateThreeDsSessionRequest{
		AuthenticationCategory: "payment",
		AuthenticationType:     "payment-transaction",
	}

	purchaseInfo := &basistheory.ThreeDsPurchaseInfo{
		Amount:   pointerToString("80000"),
		Currency: pointerToString("826"),
		Exponent: pointerToString("2"),
		Date:     pointerToString("20240109141010"),
	}

	requestorInfo := &basistheory.ThreeDsRequestorInfo{
		ID:   pointerToString("example-3ds-merchant"),
		Name: pointerToString("Example 3DS Merchant"),
		URL:  pointerToString("https://www.example.com/example-merchant"),
	}

	merchantInfo := &basistheory.ThreeDsMerchantInfo{
		Mid:         pointerToString("9876543210001"),
		AcquirerBin: pointerToString("000000999"),
		Name:        pointerToString("Example 3DS Merchant"),
		CategoryCode: pointerToString("7922"),
		CountryCode: pointerToString("826"),
	}

	cardholderInfo := &basistheory.ThreeDsCardholderInfo{
		Name:  pointerToString("John Doe"),
		Email: pointerToString("john@me.com"),
	}

	authRequest.PurchaseInfo = purchaseInfo
	authRequest.RequestorInfo = requestorInfo
	authRequest.MerchantInfo = merchantInfo
	authRequest.CardholderInfo = cardholderInfo

	authenticateResponse, authenticateErr := client.Threeds.Sessions.Authenticate(context.Background(), sessionId, authRequest)

	if authenticateErr != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(rw).Encode(map[string]string{"error": authenticateErr.Error()})
		return
	}

	rw.WriteHeader(http.StatusOK)
	json.NewEncoder(rw).Encode(authenticateResponse)
}
//highlight-end
```
</TabItem>
</Tabs>

<Alert type={Alerts.WARNING}>On a production environment, your endpoint to authorize sessions should be behind your own authorization scheme.</Alert>

<Alert>Be sure to replace <code>&lt;PRIVATE_API_KEY></code> with the Private API Key you created previously.</Alert>

And then passing that information back to your frontend.

<Alert>You need to pass your authentication endpoint URL and any additional headers to the `withAuthenticationEndpoint` function in the `ThreeDSServiceBuilder` for both native mobile SDK's. The authentication step is executed when the `startChallenge` method is invoked.</Alert>


```typescript showLineNumbers
import { BasisTheory3ds } from "@basis-theory/web-threeds";

const checkout = async () => {
  // initializing the 3ds sdk
  const bt3ds = BasisTheory3ds("<PUBLIC_API_KEY>");

  // creating the session
  const session = await bt3ds.createSession({ pan: "<CARD_TOKEN_ID>" });

  //highlight-start
  // authenticating the session
  const authResponse = await fetch(
    `{your-backend-host}/${session.id}/authenticate`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  const authentication = await authResponse.json();
  //highlight-end
};
```

If the `status` for the authentication response is `successful`, that means a frictionless authentication happened and the authentication token is available as the `authentication_value` property.

## Performing a Challenge

If after authenticating a 3DS session, the authentication response `status` is set as `challenge`, that means that the customer needs to perform a challenge, like inputting a passcode, before getting the final 3DS authentication value.

You can trigger the user challenge by calling the `startChallenge` method, which returns a `Promise` that will only be resolved once the user completes it.
By default, `startChallenge` will time out and reject the `Promise` if the user does not complete the challenge within 60000ms (1 minute). This can be configured by passing the `timeout` property in the challenge object.


<Tabs className="bt-tabs" queryString="frontend">
  <TabItem value="ts" label="Web">
```typescript showLineNumbers
import { BasisTheory3ds } from "@basis-theory/web-threeds";

const checkout = async () => {
  // initializing the 3ds sdk
  const bt3ds = BasisTheory3ds("<PUBLIC_API_KEY>");

  // creating the session
  const session = await bt3ds.createSession({ pan: "<CARD_TOKEN_ID>" });

  // authenticating the session
  const authResponse = await fetch(
    `{your-backend-host}/${session.id}/authenticate`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  const authentication = await authResponse.json();

  //highlight-start
  if (authentication.status === "challenge") {
    // some information about the authentication is necessary to start a challenge
    const challengeInfo = {
      acsChallengeUrl: authentication.acs_challenge_url,
      acsTransactionId: authentication.acs_transaction_id,
      sessionId: session.id,
      threeDSVersion: authentication.threeds_version,
    };

    // starting a challenge
    // the response is just an object w/ the session id: { id: sessionId }
    const challengeCompleted = await bt3ds.startChallenge(challengeInfo);
  }
  //highlight-end
};
```
  </TabItem>

  <TabItem value="ios" label="iOS">
```swift showLineNumbers
class ViewController: UIViewController {
    private var threeDSService: ThreeDSService! // important to keep `threeDSService` outside of the Task, otherwise swift will handle it as a weak reference and you may experience undesired behavior
    let customHeaders: [String: String] = [
          "Authorization": "Bearer your_token_here",
          "Trace-Id": "your_trace_id_here"
      ]

    override func viewDidLoad() {
        super.viewDidLoad()

        Task {
            do {
                threeDSService = try ThreeDSService.builder()
                    .withApiKey("<YOUR PUBLIC API KEY>")
                    .withAuthenticationEndpoint("<YOUR AUTHENTICATION ENDPOINT>", customHeaders)
                    .build()

                try await threeDSService.initialize { [weak self] warnings in
                        if let warnings = warnings, !warnings.isEmpty {
                            let messages = warnings.map { $0.message }.joined(separator: "\n")

                            print(messages)
                        } else {
                            print("No warnings.")
                        }
                }

                let session = try await threeDSService.createSession(tokenId: "<CARD TOKEN ID>")

                //highlight-start
                // start challenge
                try await threeDSService.startChallenge(sessionId: session.id, viewController: self,
                    onCompleted: { result in
                        print("Challenge \(result.status)")

                        guard let details = result.details else {
                            return
                        }

                        print(details)
                    },
                    onFailure: { [self] result in
                        print("Challenge \(result.status)")
                    })

                //highlight-end
            } catch {
                print(error.localizedDescription)
            }
        }
    }
}
```
  </TabItem>

  <TabItem value="android" label="Android">
```kotlin showLineNumbers
val customHeaders = Headers.Builder()
        .add("Authorization", "Bearer your_token_here")
        .add("Trace-Id", "your_trace_id_here")
        .build();

val threeDSService = ThreeDsService.Builder()
  .withApiKey("<PUBLIC_API_KEY>")
  .withApplicationContext(context)
  .withAuthenticationEndpoint("Your 3DS authentication endpoint URL", customHeaders) // https://developers.basistheory.com/docs/guides/process/authenticate-with-3ds#authenticating-a-session
  .apply {
      // make sure withSandbox is removed in production environments
      if (BuildConfig.DEBUG) {
        withSandbox()
      }
  }
  .build()

val warnings = threeDSService.initialize()

if (!warnings.isNullOrEmpty()) {
  // inspect warnings
}


val session = threeDSService.createSession("<CARD_TOKEN_ID>")

//highlight-start
// start challenge
threeDsService.startChallenge(
  sessionId,
  activity,
  ::onChallengeCompleted,
  ::onChallengeFailed
)

fun onChallengeCompleted(result: ChallengeResponse) {
  Log.i("3ds_service", "Challenge completed with status: ${result.status}");

  result.details?.let {
    Log.i("3ds_service", it);
  }
}

fun onChallengeFailed(result: ChallengeResponse) {
  Log.i("Challenge failed with status: ${result.status}")
}
//highlight-end
```
  </TabItem>

  <TabItem value="react" label="React Native">
```jsx showLineNumbers
import { BasisTheory3dsProvider, useBasisTheory3ds } from "@basis-theory/react-native-threeds";

const App = () => {
  return (
    <BasisTheory3dsProvider apiKey={"<PUBLIC_API_KEY>"}>
      <MyApp />
    </BasisTheory3dsProvider>
  );
}

const MyApp = () => {
  const { createSession, startChallenge } = useBasisTheory3ds();

  //creating the session
  const session = await createSession({ tokenId: "<CARD_TOKEN_ID>" });

  // authenticating the session
  const authResponse = await fetch(
    `{your-backend-host}/${session.id}/authenticate`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  const authentication = await authResponse.json();

  //highlight-start
  if (authentication.status === "challenge") {
    // some information about the authentication is necessary to start a challenge
    const challengeInfo = {
      acsChallengeUrl: authentication.acs_challenge_url,
      acsTransactionId: authentication.acs_transaction_id,
      sessionId: session.id,
      threeDSVersion: authentication.threeds_version,
    };

    // starting a challenge
    // the response is true if the challenge was completed, false if there was an error
    const challengeCompleted = await startChallenge(challengeInfo);
  }
  //highlight-end
}
```
  </TabItem>
</Tabs>

### Styling the Challenge Window (Web)

<Alert>Styling of the challenge window is not supported in the mobile SDK\'s yet. Contact <a href="mailto:support@basistheory.com?subject=Styling 3DS mobile">support@basistheory.com</a> for more information.</Alert>


The internal challenge 'window' is created and handled by card issuer and unfortunately there is not much that can be done to style it to fit with the design of your website.

What is possible though, is determining how big that window can be, and style the container that holds it.

#### Changing the Window Size

To change the window size, use the `windowSize` property on the challenge request, passing along the code for the desired pre-defined size according to the table below.

```jsx showLineNumbers
const challengeInfo = {
  //... other challenge props
  //highlight-start
  windowSize = '01'
  //highlight-end
};

const challengeCompleted = await basisTheory3ds.startChallenge(challengeInfo);
```

By default, the challenge window size is set to `03` or `500px x 600px`

| WindowSize ID | Size |
| --- | --- |
| 01 | 250px x 400px |
| 02 | 390px x 400px |
| 03 | 500px x 600px |
| 04 | 600px x 400px |
| 05 | 100% x 100% |

#### Style the Window Container

The challenge window is an `iframe` that gets loaded inside a predefined container `div`.

The container div always has a default id - `challengeFrameContainer`, and that can be used to style it:

```css showLineNumbers
#challengeFrameContainer {
  display: none;
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.5)
}
```

#### Using your own Window Container

If you want more flexibility in styling, like being able to embed the window on your own content or not having to rely on `absolute` positioning, you can use your own container for the challenge window.
This can be done by passing the `id` for your desired container in the `challengeContainerOptions` object during initialization:

```typescript showLineNumbers
import { BasisTheory3ds } from "@basis-theory/web-threeds";

const bt3ds = BasisTheory3ds("<PUBLIC_API_KEY>", {
  //highlight-start
  challengeContainerOptions: { id: "your_container_id" },
  //highlight-end
});
```

## Retrieving a Challenge Result

<Alert>
Keep in mind that the results from Test Tenants are mocked results and not actual results from the card issuer. These results should be used to prove your integration is working, but can not be used to test downstream processor 3DS integrations.
</Alert>

Once a challenge is complete, results are retrieved by calling the [Get Challenge Result](/docs/api/3ds/sessions#get-challenge-result) endpoint from your backend.

This is done by calling the Basis Theory backend endpoint `/3ds/{sessionId}/sessions/challenge-result`  from your own backend, using the same private API key that was used to authenticate.

<Tabs className="bt-tabs" queryString="backend">
  <TabItem value="node" label="Node">
    In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/node) and [Express framework](https://expressjs.com/) for Node.js.

```javascript showLineNumbers
const { BasisTheory } = require("@basis-theory/basis-theory-js");
const express = require("express");

const app = express();
const PORT = 3000;

app.use(express.json());

let bt;
(async () => {
  bt = await new BasisTheory().init("<API_KEY>");
})();

app.post("/:sessionId/authenticate", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const authentication = await bt.threeds.authenticateSession(sessionId, {
      authenticationCategory: "payment",
      authenticationType: "payment-transaction",
      purchaseInfo: {
        amount: "80000",
        currency: "826",
        exponent: "2",
        date: "20240109141010"
      },
      requestorInfo: {
        id: "example-3ds-merchant",
        name: "Example 3DS Merchant",
        url: "https://www.example.com/example-merchant"
      },
      merchantInfo: {
        mid: "9876543210001",
        acquirerBin: "000000999",
        name: "Example 3DS Merchant",
        categoryCode: "7922",
        countryCode: "826"
      },
      cardholderInfo: {
        name: "John Doe",
        email: "john@me.com"
      }
    });
    res.status(200).send(authentication);
  } catch (error) {
    console.error('Error during authentication:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});

//highlight-start
app.get("/:sessionId/challenge-result", async (req, res) => {
  const { sessionId } = req.params;

  try {
    const result = await bt.threeds.getChallengeResult(sessionId);
    res.status(200).send(result);
  } catch (error) {
    console.error('Error getting challenge result:', error);
    res.status(500).send({ error: "Internal Server Error" });
  }
});
//highlight-end

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

    ```
  </TabItem>

  <TabItem value="dotnet" label=".NET">
    In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/dotnet) and [ASP.NET Core Framework](https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0).

    ```csharp showLineNumbers
    using System;
    using System.Collections.Generic;
    using Microsoft.AspNetCore;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Hosting;
    using System.Threading.Tasks;

    using BasisTheory.net.ThreeDS;
    using BasisTheory.net.ThreeDS.Requests;

    namespace server.Controllers
    {
      public class Program
      {
        public static void Main(string[] args)
        {
          WebHost.CreateDefaultBuilder(args)
            .UseUrls("http://0.0.0.0:4242")
            .UseWebRoot("public")
            .UseStartup<Startup>()
            .Build()
            .Run();
        }
      }

      public class Startup
      {
        public void ConfigureServices(IServiceCollection services)
        {
          services.AddMvc().AddNewtonsoftJson();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
          if (env.IsDevelopment()) app.UseDeveloperExceptionPage();
          app.UseRouting();
          app.UseStaticFiles();
          app.UseEndpoints(endpoints => endpoints.MapControllers());
        }
      }

      [ApiController]
      public class ThreeDsApiController : Controller
      {
        private readonly ThreeDSClient _client;

        public ThreeDsApiController()
        {
          _client = new ThreeDSClient("<PRIVATE_API_KEY>");
        }

        [HttpPost("{sessionId:guid}/authenticate")]
        public async Task<ActionResult> AuthenticateSession([FromRoute] Guid sessionId)
        {
          var authentication = await _client.AuthenticateThreeDSSessionAsync(sessionId.ToString(), new AuthenticateThreeDSSessionRequest
          {
            AuthenticationCategory = "payment",
            AuthenticationType = "payment-transaction",
            PurchaseInfo = new ThreeDSPurchaseInfo
            {
              Amount = "80000",
              Currency = "826",
              Exponent = "2",
              Date = "20240109141010"
            },
            RequestorInfo = new ThreeDSRequestorInfo
            {
              Id = "example-3ds-merchant",
              Name = "Example 3DS Merchant",
              Url = "https://www.example.com/example-merchant"
            },
            MerchantInfo = new ThreeDSMerchantInfo
            {
              Mid = "9876543210001",
              AcquirerBin = "000000999",
              Name = "Example 3DS Merchant",
              CategoryCode = "7922",
              CountryCode = "826"
            },
            CardholderInfo = new ThreeDSCardholderInfo
            {
              Name = "John Doe",
              Email = "john@me.com"
            }
          });

          if (authentication == null)
          {
            return BadRequest("Failed to authenticate session.");
          }

          return Ok(authentication);
        }

        //highlight-start
        [HttpGet("{sessionId:guid}/challenge-result")]
        public async Task<ActionResult> GetChallengeResult([FromRoute] Guid sessionId)
        {
          var result = await _client.GetChallengeResultAsync(sessionId.ToString());

          if (result == null)
          {
            return BadRequest("Failed to get challenge result.");
          }

          return Ok(result);
        }
        //highlight-end
      }
    }
    ```
  </TabItem>

  <TabItem value="python" label="Python">
    In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/python) and [Flask Framework](https://flask.palletsprojects.com/).

    ```python showLineNumbers
    import os
    from flask import Flask, request, jsonify

    import basistheory
    from basistheory.api import three_ds_api
    from basistheory.model import AuthenticateThreeDSSessionRequest, ThreeDSPurchaseInfo, ThreeDSRequestorInfo, ThreeDSMerchantInfo, ThreeDSCardholderInfo

    app = Flask(__name__)

    @app.route('/<sessionId>/authenticate', methods=['POST'])
    def authenticate_session(sessionId):
      config = basistheory.Configuration(
        host="https://api.basistheory.com",
        api_key="<PRIVATE_API_KEY>"
      )

      with basistheory.ApiClient(configuration=config) as api_client:
        three_ds_client = three_ds_api.ThreeDSApi(api_client)
        authentication_request = AuthenticateThreeDSSessionRequest(
          authentication_category="payment",
          authentication_type="payment-transaction",
          purchase_info=ThreeDSPurchaseInfo(
            amount="80000",
            currency="826",
            exponent="2",
            date="20240109141010"
          ),
          requestor_info=ThreeDSRequestorInfo(
            id="example-3ds-merchant",
            name="Example 3DS Merchant",
            url="https://www.example.com/example-merchant"
          ),
          merchant_info=ThreeDSMerchantInfo(
            mid="9876543210001",
            acquirer_bin="000000999",
            name="Example 3DS Merchant",
            category_code="7922",
            country_code="826"
          ),
          cardholder_info=ThreeDSCardholderInfo(
            name="John Doe",
            email="john@me.com"
          )
        )
        authentication = three_ds_client.three_ds_authenticate_session(sessionId, authenticate_three_ds_session_request=authentication_request)
        return jsonify(authentication.to_dict()), 200

    #highlight-start
    @app.route('/<sessionId>/challenge-result', methods=['GET'])
    def get_challenge_result(sessionId):
      config = basistheory.Configuration(
        host="https://api.basistheory.com",
        api_key="<PRIVATE_API_KEY>"
      )

      with basistheory.ApiClient(configuration=config) as api_client:
        three_ds_client = three_ds_api.ThreeDSApi(api_client)

        result = three_ds_client.three_ds_get_challenge_result(session_id=sessionId)
        return jsonify(result.to_dict()), 200
    #highlight-end

    if __name__ == '__main__':
      app.run(port=4242, debug=True)
    ```
  </TabItem>

  <TabItem value="go" label="Go">
    In this example, we are using [Basis Theory SDK](/docs/sdks/server-side/go), [Go HTTP package](https://pkg.go.dev/net/http) and the [Gorilla Mux Router](https://github.com/gorilla/mux).

    ```go showLineNumbers
    package main

    import (
      "context"
      "encoding/json"
      "log"
      "net/http"
      "github.com/Basis-Theory/basistheory-go/v5"
      "github.com/gorilla/mux"
    )

    func main() {
      router := mux.NewRouter()
      router.HandleFunc("/{sessionId}/authenticate", authenticateSession).Methods("POST")
      //highlight-start
      router.HandleFunc("/{sessionId}/challenge-result", getChallengeResult).Methods("GET")
      //highlight-end
      addr := "localhost:4242"
      log.Printf("Listening on %s", addr)
      log.Fatal(http.ListenAndServe(addr, router))
    }

    func authenticateSession(rw http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      sessionId := vars["sessionId"]

      configuration := basistheory.NewConfiguration()
      apiClient := basistheory.NewAPIClient(configuration)
      contextWithAPIKey := context.WithValue(context.Background(), basistheory.ContextAPIKeys, map[string]basistheory.APIKey{
        "ApiKey": {Key: "<PRIVATE_API_KEY>"},
      })

      authenticateThreeDSSessionRequest := *basistheory.NewAuthenticateThreeDSSessionRequest()
      authenticateThreeDSSessionRequest.SetAuthenticationCategory("payment")
      authenticateThreeDSSessionRequest.SetAuthenticationType("payment-transaction")

      purchaseInfo := *basistheory.NewThreeDSPurchaseInfo()
      purchaseInfo.SetAmount("80000")
      purchaseInfo.SetCurrency("826")
      purchaseInfo.SetExponent("2")
      purchaseInfo.SetDate("20240109141010")

      requestorInfo := *basistheory.NewThreeDSRequestorInfo()
      requestorInfo.SetId("example-3ds-merchant")
      requestorInfo.SetName("Example 3DS Merchant")
      requestorInfo.SetUrl("https://www.example.com/example-merchant")

      merchantInfo := *basistheory.NewThreeDSMerchantInfo()
      merchantInfo.SetMid("9876543210001")
      merchantInfo.SetAcquirerBin("000000999")
      merchantInfo.SetName("Example 3DS Merchant")
      merchantInfo.SetCategoryCode("7922")
      merchantInfo.SetCountryCode("826")

      cardholderInfo := *basistheory.NewThreeDSCardholderInfo()
      cardholderInfo.SetName("John Doe")
      cardholderInfo.SetEmail("john@me.com")

      authenticateThreeDSSessionRequest.SetPurchaseInfo(purchaseInfo)
      authenticateThreeDSSessionRequest.SetRequestorInfo(requestorInfo)
      authenticateThreeDSSessionRequest.SetMerchantInfo(merchantInfo)
      authenticateThreeDSSessionRequest.SetCardholderInfo(cardholderInfo)

      authenticateResponse, _, authenticateErr := apiClient.ThreeDSApi.ThreeDSAuthenticateSession(contextWithAPIKey, sessionId).AuthenticateThreeDSSessionRequest(authenticateThreeDSSessionRequest).Execute()
      if authenticateErr != nil {
        rw.WriteHeader(http.StatusInternalServerError)
        json.NewEncoder(rw).Encode(map[string]string{"error": authenticateErr.Error()})
        return
      }

      rw.WriteHeader(http.StatusOK)
      json.NewEncoder(rw).Encode(authenticateResponse)
    }

    //highlight-start
    func getChallengeResult(rw http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      sessionId := vars["sessionId"]

      configuration := basistheory.NewConfiguration()
      apiClient := basistheory.NewAPIClient(configuration)
      contextWithAPIKey := context.WithValue(context.Background(), basistheory.ContextAPIKeys, map[string]basistheory.APIKey{
        "ApiKey": {Key: "<PRIVATE_API_KEY>"},
      })

      challengeResult, _, err := apiClient.ThreeDSApi.ThreeDSGetChallengeResult(contextWithAPIKey, sessionId).Execute()
      if err != nil {
        rw.WriteHeader(http.StatusInternalServerError)
        json.NewEncoder(rw).Encode(map[string]string{"error": err.Error()})
        return
      }

      rw.WriteHeader(http.StatusOK)
      json.NewEncoder(rw).Encode(challengeResult)
    }
    //highlight-end

    ```
  </TabItem>
</Tabs>

And then passing that information along back to your frontend.

<Tabs className="bt-tabs" queryString="frontend">
  <TabItem value="ts" label="Web">
```typescript showLineNumbers
import { BasisTheory3ds } from "@basis-theory/web-threeds";

const checkout = async () => {
  // initializing the 3ds sdk
  const bt3ds = BasisTheory3ds("<PUBLIC_API_KEY>");

  // creating the session
  const session = await bt3ds.createSession({ pan: "<CARD_TOKEN_ID>" });

  // authenticating the session
  const authResponse = await fetch(
    `{your-backend-host}/${session.id}/authenticate`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  const authentication = await authResponse.json();

  if (authentication.status === "challenge") {
    // some information about the authentication is necessary to start a challenge
    const challengeInfo = {
      acsChallengeUrl: authentication.acs_challenge_url,
      acsTransactionId: authentication.acs_transaction_id,
      sessionId: session.id,
      threeDSVersion: authentication.threeds_version,
    };

    // starting a challenge
    // the response is just an object w/ the session id: { id: sessionId }
    const challengeCompleted = await bt3ds.startChallenge(challengeInfo);

    //highlight-start
    // getting challenge result
    const resultResponse = await fetch(
      `{your-backend-host}/${session.id}/challenge-result`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    const result = await resultResponse.json();
    //highlight-end
  }
};
```
      </TabItem>
  <TabItem value="ios" label="iOS">
```swift showLineNumbers
let customHeaders: [String: String] = [
    "Authorization": "Bearer your_token_here",
    "Trace-Id": "your_trace_id_here"
]

private var threeDSService: ThreeDSService!
private var sessionId: String? = nil

threeDSService = try ThreeDSService.builder()
  .withApiKey("<PUBLIC_API_KEY>")
  .withAuthenticationEndpoint("Your 3DS authentication endpoint URL", customHeaders) // https://developers.basistheory.com/docs/guides/process/authenticate-with-3ds#authenticating-a-session
  .withSandbox()   // make sure withSandbox is removed in production environments
  .build()


Task {
  try await threeDSService.initialize { [weak self] warnings in
      if let warnings = warnings, !warnings.isEmpty {
          // inspect warnings
      }
  }

  let session = try await self.threeDSService.createSession(tokenId: "<CARD_TOKEN_ID>")

  try await self.threeDSService.startChallenge(
      sessionId: session.id, viewController: self,
      onCompleted: { result in
          print("Challenge completed with status: \(result.status)")

          guard let details = result.details else {
              return
          }

          print(details)
      },
      onFailure: { result in
          print("Challenge failed with status: \(result.status)")
      })


  //highlight-start
  // getting challenge result
  let endpoint = URL(string: "{your-backend-host}/challenge-result")!

  let jsonBody: [String: String] = [
      "sessionId": session.id
  ]

  let requestBody = try JSONSerialization.data(withJSONObject: jsonBody, options: [])

  var request = URLRequest(url: endpoint)
  request.httpMethod = "POST"
  request.addValue("application/json", forHTTPHeaderField: "Content-Type")
  request.httpBody = requestBody

  let (data, _) = try await URLSession.shared.data(for: request)

  let decodedResponse = try JSONDecoder().decode(ChallengeResult.self, from: data)

  print(decodedResponse.authenticationStatus)

  guard let reason = decodedResponse.authenticationStatusReason else {
    return
  }

  print(reason)
  //highlight-end
}
```
  </TabItem>

  <TabItem value="android" label="Android">
```kotlin showLineNumbers
val customHeaders = Headers.Builder()
        .add("Authorization", "Bearer your_token_here")
        .add("Trace-Id", "your_trace_id_here")
        .build();

val threeDSService = ThreeDsService.Builder()
  .withApiKey("<PUBLIC_API_KEY>")
  .withApplicationContext(context)
  .withAuthenticationEndpoint("Your 3DS authentication endpoint URL", customHeaders) // https://developers.basistheory.com/docs/guides/process/authenticate-with-3ds#authenticating-a-session
  .apply {
      // make sure withSandbox is removed in production environments
      if (BuildConfig.DEBUG) {
        withSandbox()
      }
  }
  .build()

val warnings = threeDSService.initialize()

if (!warnings.isNullOrEmpty()) {
  // inspect warnings
}


val session = threeDSService.createSession("<CARD_TOKEN_ID>")

threeDsService.startChallenge(
  sessionId,
  activity,
  ::onChallengeCompleted,
  ::onChallengeFailed
)

fun onChallengeCompleted(result: ChallengeResponse) {
  Log.i("3ds_service", "Challenge completed with status: ${result.status}");

  result.details?.let {
    Log.i("3ds_service", it);
  }
}

fun onChallengeFailed(result: ChallengeResponse) {
  Log.i("Challenge failed with status: ${result.status}")
}
//highlight-start
// getting challenge result
val client = OkHttpClient()
val payload = JSONObject().apply {
  put("sessionId", sessionId)
}.toString()

val req = Request.Builder()
  .url("{your-backend-host}/challenge-result")
  .post(payload.toRequestBody("application/json".toMediaType()))
  .build()

client.newCall(req)
    .execute().use {
        val responseBody = requireNotNull(it.body?.string())
        it.body?.close()

        if (!it.isSuccessful) {
            throw Error("Unable to authenticate, downstream service responded ${it.code} for session $sessionId, ${it.message}")
        }
        Log.i(responseBody)
    }
//highlight-end
  ```
  </TabItem>

    <TabItem value="react" label="React Native">
```jsx showLineNumbers
import { BasisTheory3dsProvider, useBasisTheory3ds } from "@basis-theory/react-native-threeds";

const App = () => {
  return (
    <BasisTheory3dsProvider apiKey={"<PUBLIC_API_KEY>"}>
      <MyApp />
    </BasisTheory3dsProvider>
  );
}

const MyApp = () => {
  const { createSession, startChallenge } = useBasisTheory3ds();

  //creating the session
  const session = await createSession({ tokenId: "<CARD_TOKEN_ID>" });

  // authenticating the session
  const authResponse = await fetch(
    `{your-backend-host}/${session.id}/authenticate`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  const authentication = await authResponse.json();

  if (authentication.status === "challenge") {
    // some information about the authentication is necessary to start a challenge
    const challengeInfo = {
      acsChallengeUrl: authentication.acs_challenge_url,
      acsTransactionId: authentication.acs_transaction_id,
      sessionId: session.id,
      threeDSVersion: authentication.threeds_version,
    };

    // starting a challenge
    // the response is true if the challenge was completed, false if there was an error
    const challengeCompleted = await startChallenge(challengeInfo);
  }

     //highlight-start
    // getting challenge result
    const resultResponse = await fetch(
      `{your-backend-host}/${session.id}/challenge-result`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    const result = await resultResponse.json();
    //highlight-end
}
```
  </TabItem>
</Tabs>

That's it 🎉!
The result from the `authentication` (in case of frictionless) or `challenge-result` calls contains the authentication token (`authentication_value` attribute) and any other information needed to fully process the 3DS transaction.
See below how to integrate this information with popular payment providers.

# Integrating 3DS Results with your Payment Provider

Once you have completed all necessary 3DS operations using our solution, the next step is to integrate the results with your payment provider.
This section provides guidance on mapping and utilizing the 3DS results for successful transaction processing with popular payment providers.
Proper mapping ensures seamless communication and compliance with your provider's requirements.

<Alert type={Alerts.INFO}>If your provider is not listed here or you need further assistance with integration, please contact our team at <a href="mailto:support@basistheory.com">support@basistheory.com</a>.</Alert>

## Integrating with Adyen

The table below outlines the mapping of Basis Theory 3DS results to Adyen fields, based on their [official documentation](https://docs.adyen.com/online-payments/3d-secure/authorize-mpidata/?tab=3ds2-request_1).

| Adyen Field | Basis Theory 3DS Value | Notes |
| --- | --- | --- |
| `paymentMethod.type` | - | This value is specific to Adyen's payment flow, refer to official documentation. |
| `mpiData.authenticationResponse` | `authentication.authentication_status_code` | If challenge was required, take this value after retrieving the [challenge result](#retrieving-a-challenge-result). Otherwise (if frictionless), after [authentication](#authenticating-a-session) .|
| `mpiData.directoryResponse` | `authentication.authentication_status_code` | Take this value after [authenticating](#authenticating-a-session) the session, regardless of challenge or not. |
| `mpiData.cavv` | `authentication.authentication_value` | - |
| `dsTransID` | `authentication.ds_transaction_id` | - |
| `mpiData.eci` | `authentication.eci` | - |
| `mpiData.threeDSVersion` | `authentication.threeds_version` | - |
| `threeDS2RequestData.threeDSRequestorChallengeInd` | `authentication.challenge_preference_code` | Only if a challenge preference was selected during authentication. |
| `mpiData.cavvAlgorithm` | `authentication.message_extensions[x].data`  | Applies to Cartes Bancaires only. Provided as part of an unspecified message extensions. Contact Adyen for more details. |
| `mpiData.challengeCancel` | `authentication.challenge_cancel_reason_code` | - |
| `mpiData.riskScore` | `authentication.message_extensions[x].data` | Applies to Cartes Bancaires only. Provided as part of an unspecified message extensions. Contact Adyen for more details. |
| `additionalData.acquirerCode` | - | Applies only to Cartes Bancaires. Adyen asks the value to be set as `AdyenCartesBancaires` |
| `additionalData.scaExemption` | - | Applies only to Cartes Bancaires. Specific to Adyen's flow, refer to Adyen's [documentation](https://docs.adyen.com/api-explorer/Checkout/latest/post/payments#request-additionalData-AdditionalData3DSecure-scaExemption). |
| `shopperInteraction` | - | Specific to Adyen's flow, refer to Adyen's [documentation](https://docs.adyen.com/api-explorer/Checkout/latest/post/payments#request-shopperInteraction). |
| `recurringProcessingModel` | - | Specific to Adyen's flow, refer to Adyen's [documentation](https://docs.adyen.com/api-explorer/Checkout/latest/post/payments#request-recurringProcessingModel). |

## Integrating with Stripe

The table below outlines the mapping of Basis Theory 3DS results to Stripe fields, based on their [official documentation](https://docs.stripe.com/payments/payment-intents/three-d-secure-import).

| Stripe Field | Basis Theory 3DS Value | Notes |
| --- | --- | --- |
| `three_d_secure.cryptogram` | `authentication.authentication_value` | - |
| `three_d_secure.transaction_id` | `authentication.ds_transaction_id` | - |
| `three_d_secure.version` | `authentication.threeds_version` | - |
| `three_d_secure.ares_trans_status` | `authentication.authentication_status_code` | - |
| `three_d_secure.electronic_commerce_indicator` | `authentication.eci` | - |
| `three_d_secure.exemption_indicator` | - | Specific to Stripe's flow, refer to Stripe's [documentation](https://docs.stripe.com/api/payment_intents/create#create_payment_intent-payment_method_options-card-three_d_secure-exemption_indicator). |
| `three_d_secure.network_options` | See [Stripe Network Options](#stripe-network-options) below. | - |
| `three_d_secure.requestor_challenge_indicator` | `authentication.challenge_preference_code` | Only if a challenge preference was selected during authentication. |

### Stripe Network Options
| Stripe Network Options Field | Basis Theory 3DS Value | Notes |
| --- | --- | --- |
| `cartes_bancaires.cb_avalgo` | `authentication.message_extensions[x].data` | Check `authentication.message_extensions` array for `message_extensions[x].name == CB-AVALGO` for the value of x (index). |
| `cartes_bancaires.cb_exemption` | `authentication.message_extensions[x].data` | Check `authentication.message_extensions` array for `message_extensions[x].name == CB-EXEMPTION` for the value of x (index). |
| `cartes_bancaires.cb_score` | `authentication.message_extensions[x].data` | Check `authentication.message_extensions` array for `message_extensions[x].name == CB-SCORE` for the value of x (index). |

## Integrating with Checkout

The table below outlines the mapping of Basis Theory 3DS results to Checkout.com fields, based on their [official documentation](https://www.checkout.com/docs/payments/authenticate-payments#Authenticate_payments_using_a_third-party_provider).

| Stripe Field | Basis Theory 3DS Value | Notes |
| --- | --- | --- |
| `3ds.challenge_indicator` | See [Checkout Challenge Indicator](#checkout-challenge-indicator) below. | - |
| `3ds.cryptogram` | `authentication.authentication_value` | - |
| `3ds.eci` | `authentication.eci` | - |
| `3ds.enabled` | - | Checkout asks the value to be set as `true` for using 3ds. |
| `3ds.version` | `authentication.threeds_version` | - |
| `3ds.xid` | `authentication.ds_transaction_id` | - |
| `success_url` | - | From Checkout: 'The URL that the cardholder is redirected to when 3DS authentication is successful.' |
| `failure_url` | - | From Checkout: 'The URL that the cardholder is redirected to when 3DS authentication fails.' |

### Checkout Challenge Indicator
| Basis Theory `challenge_preference` | Basis Theory `challenge_preference_code` | Checkout `challenge_indicator` |
| --- | --- | --- |
| `no-preference` | `01` | `no_preference` |
| `no-challenge` | `02` | `no_challenge_requested` |
| `challenge-requested` | `03` | `challenge_requested` |
| `challenge-mandated` | `04` | `challenge_requested_mandate` |

**Note**: Basis Theory provides additional challenge preference values, but Checkout.com only supports the above values.

## Learn More

- [3DS API Reference](/docs/api/3ds/sessions)
