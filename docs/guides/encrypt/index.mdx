---
title: Token Encryption
hide_title: true
hide_table_of_contents: true
---

import Encrypt from "@site/static/img/guides/encrypt/encrypt-guide.svg";
import { Intro } from "@site/src/components/shared/Intro";
import { Card } from "@site/src/components/shared/Card";

<Intro
  title="Token Encryption"
  caption="Encrypt sensitive data on the client side for optimized tokenization workflows."
  img={{
    light: "/img/guides/encrypt/logo-light.svg",
    dark: "/img/guides/encrypt/logo-dark.svg",
  }}
/>

Client-side encryption enables you to encrypt sensitive data in your frontend applications and send the encrypted payload to your backend for tokenization. This approach reduces latency, improves user experience, and gives you more control over when and how data is sent to Basis Theory.

### How encrypted token creation works

**Step 1: Generate a Client Encryption Key**
Use the [Client Encryption Keys API](/docs/api/client-keys#create-client-encryption-key) to create an asymmetric key pair. This returns a public key in PEM format and a unique key ID.

```bash
# Example: Create encryption key
curl -X POST "https://api.basistheory.com/keys" \
  -H "BT-API-KEY: <MANAGEMENT_API_KEY>" \
  -H "Content-Type: application/json" \
  -d '{"expires_at": "2025-12-31T23:59:59Z"}'
```

**Step 2: Client-side encryption**
Use the public key (PEM format) and key ID to encrypt your token creation payload in your frontend application, typically with Basis Theory Elements. The encrypted payload contains the same data you would normally send in the `data` attribute.

**Step 3: Send encrypted payload to your backend**
Your frontend receives the encrypted payload and sends it to your backend. Your backend can then create the token using the encrypted data instead of plaintext.

**Step 4: Create token with encrypted data**
Send the encrypted payload in the `encrypted` attribute instead of using the `data` attribute.

```bash
# Example: Create token with encrypted payload
curl "https://api.basistheory.com/tokens" \
  -H "BT-API-KEY: <API_KEY>" \
  -H "Content-Type: application/json" \
  -X "POST" \
  -d '{
    "type": "card",
    "encrypted": "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6...",
    "metadata": {
      "customer_id": "12345"
    }
  }'
```
See more details in the [Token Creation](/docs/api/tokens#encrypted-token-creation) API reference.

## Key Benefits

### Reduced Latency
Encrypt data immediately in your frontend and provide instant user feedback, while tokenization happens asynchronously in your backend.

### Enhanced Control
Maintain full control over when and how sensitive data is processed, with encrypted payloads that remain secure until your backend is ready.

### Improved Performance
Leverage your backend infrastructure's reliable connections and processing power for tokenization operations.

### Seamless Integration
Works with existing Basis Theory Elements and APIs, requiring minimal changes to your current implementation. 

## Platform-Specific Guides

<Card.TwoColumnLayout>
  <Card
    column
    img={<Encrypt />}
    href="/docs/guides/encrypt/encrypt-data-from-web"
    heading="Encrypt Data from Web"
  >Implement client-side encryption in vanilla JavaScript web applications.</Card>

  <Card
    column
    img={<Encrypt />}
    href="/docs/guides/encrypt/encrypt-data-with-react"
    heading="Encrypt Data with React"
  >Implement client-side encryption in React applications using Elements.</Card>

  <Card
    column
    img={<Encrypt />}
    href="/docs/guides/encrypt/encrypt-data-with-ios"
    heading="Encrypt Data with iOS"
  >Implement client-side encryption in iOS applications using Elements.</Card>

  <Card
    column
    img={<Encrypt />}
    href="/docs/guides/encrypt/encrypt-data-with-android"
    heading="Encrypt Data with Android"
  >Implement client-side encryption in Android applications using Elements.</Card>

  <Card
    column
    img={<Encrypt />}
    href="/docs/guides/encrypt/encrypt-data-with-react-native"
    heading="Encrypt Data with React Native"
  >Implement client-side encryption in React Native applications.</Card>
</Card.TwoColumnLayout>
