---
title: Encrypt Data with React Native
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { Alert, Alerts } from "@site/src/components/shared/Alert";
import { AuthButtons } from "@site/src/components/docs/AuthButtons";

# Encrypt Data with React Native

This guide will show you how to implement client-side encryption in React Native applications using Basis Theory Elements. You'll learn to encrypt sensitive data in React Native and send encrypted payloads to your backend for tokenization.

Key concepts in this guide:

- [Client Encryption Keys](/docs/api/client-keys)
- [React Native Elements](/docs/sdks/web/web-elements?implementation=react)
- [Tokens](/docs/concepts/what-are-tokens)
- [Applications](/docs/api/applications)

## What You'll Build

By the end of this guide, you'll have:
- A React Native payment form that encrypts card data before submission
- Cross-platform encryption that works on both iOS and Android
- Encrypted payloads sent to your backend instead of plaintext
- Immediate user feedback while tokenization happens asynchronously

## Getting Started

To get started, you will need a Basis Theory account.

<AuthButtons />

Next, you will need two applications:

1. **Management Application** - to create encryption keys
2. **Public Application** - to initialize Elements for your React Native app

### Management Application

[Click here](https://portal.basistheory.com/applications/create?name=Encryption%20Key%20Manager&type=management&permissions=key%3Acreate) to create a Management Application or [login to your Basis Theory account](https://portal.basistheory.com/applications) and create a new application with the following settings:

- Name - Encryption Key Manager
- Application Type - Management
- Permissions - `key:create`

<Alert>Save the API Key from the created Management Application as it will be used to create encryption keys.</Alert>

### Public Application

[Click here](https://portal.basistheory.com/applications/create?permissions=&type=public&name=Encrypt%20Data%20with%20React%20Native%20Guide) to create a Public Application or [login to your Basis Theory account](https://portal.basistheory.com/applications) and create a new application with the following settings:

- Name - Encrypt Data with React Native Guide
- Application Type - Public
- Permissions - (none required for client-side encryption)

<Alert>Save the API Key from the created Public Application as it will be used later in this guide to initialize the form.</Alert>

## Step 1: Generate Client Encryption Keys

Create encryption keys using your Management Application. These keys enable client-side encryption.

```bash
curl -X POST "https://api.basistheory.com/keys" \
  -H "BT-API-KEY: <MANAGEMENT_API_KEY>" \
  -H "Content-Type: application/json" \
  -d '{
    "expires_at": "2025-12-31T23:59:59Z"
  }'
```

<Alert>Be sure to replace <code>&lt;MANAGEMENT_API_KEY></code> with the Management API Key you created in the <a href="#getting-started">Getting Started</a> step.</Alert>

**Expected Response:**
```json
{
  "id": "b1e2c3d4-5678-1234-9abc-def012345678",
  "publicKeyPEM": "-----BEGIN PUBLIC KEY-----\nWQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=\n-----END PUBLIC KEY-----",
  "expires_at": "2025-12-31T23:59:59Z"
}
```

<Alert type={Alerts.WARNING}>Save the public key (<code>publicKeyPEM</code>) and key ID (<code>id</code>) - you'll need both for client-side encryption. The public key is only returned when creating a key. Make sure to securely store it, as you won't be able to retrieve it later.</Alert>

## Step 2: Setup the Project

We will create a new React Native application by following the instructions outlined on React Native's environment setup [page](https://reactnative.dev/docs/environment-setup). Ensure you have the following tabs selected before starting:

1. "React Native CLI Quickstart" near the top of the page
2. Your operating system selected as the Development OS
3. Your target platform selected as the Target OS

Follow each step on this page down to "Start your application" to ensure your environment is set up correctly.

## Step 3: Install the React Native Elements SDK

We will need to install Basis Theory's React Native SDK, which will render secure Elements for capturing data and provide encryption capabilities.

```bash
npm install @basis-theory/basis-theory-react-native @basis-theory/basis-theory-js
```

### iOS Setup

```bash
cd ios && pod install
```

### Android Setup

No additional setup required for Android.

## Step 4: Initialize the SDK

Now we need to initialize Basis Theory React Elements. In your main `App.tsx` file, add the configuration:

```tsx showLineNumbers title="App.tsx"
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  ScrollView,
} from 'react-native';
import {
  BasisTheoryProvider,
  CardNumberElement,
  CardExpirationDateElement,
  CardVerificationCodeElement,
} from '@basis-theory/basis-theory-react-native';

// Your encryption key details from Step 1
const encryptionKeyId = 'b1e2c3d4-5678-1234-9abc-def012345678';
const publicKeyPEM = `-----BEGIN PUBLIC KEY-----
WQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=
-----END PUBLIC KEY-----`;

function App(): JSX.Element {
  const { bt } = useBasisTheory('<PUBLIC_API_KEY>');

  return (
    <BasisTheoryProvider bt={bt}>
      <View style={styles.container}>
        <Text style={styles.title}>Client-Side Encryption Demo</Text>
        {/* Payment form will go here */}
      </View>
    </BasisTheoryProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#333',
  },
});

export default App;
```

<Alert>Be sure to replace <code>&lt;PUBLIC_API_KEY></code> with the Public API Key you created in the <a href="#getting-started">Getting Started</a> step, and update the encryption key details with your actual key ID and public key PEM.</Alert>

## Step 5: Add Your Form Components

Now we need to add Card Elements to our application for collecting payment card data. We'll add them inside our `BasisTheoryProvider`:

```tsx showLineNumbers title="App.tsx"
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  ScrollView,
} from 'react-native';
import {
  BasisTheoryProvider,
  CardNumberElement,
  CardExpirationDateElement,
  CardVerificationCodeElement,
} from '@basis-theory/basis-theory-react-native';

// Your encryption key details from Step 1
const encryptionKeyId = 'b1e2c3d4-5678-1234-9abc-def012345678';
const publicKeyPEM = `-----BEGIN PUBLIC KEY-----
WQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=
-----END PUBLIC KEY-----`;

function App(): JSX.Element {
  const { bt } = useBasisTheory('<PUBLIC_API_KEY>');
  const [customerName, setCustomerName] = useState('');
  
  // Refs for Elements
  const cardNumberRef = useRef(null);
  const expirationDateRef = useRef(null);
  const cvcRef = useRef(null);

  return (
    <BasisTheoryProvider bt={bt}>
      <ScrollView style={styles.container}>
        <Text style={styles.title}>Client-Side Encryption Demo</Text>
        
        <View style={styles.section}>
          <Text style={styles.label}>Cardholder Name</Text>
          <TextInput
            style={styles.input}
            placeholder="John Doe"
            value={customerName}
            onChangeText={setCustomerName}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>Card Number</Text>
          <CardNumberElement
            ref={cardNumberRef}
            style={styles.cardElement}
            placeholder="Card Number"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>Expiration Date</Text>
          <CardExpirationDateElement
            ref={expirationDateRef}
            style={styles.cardElement}
            placeholder="MM/YY"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>CVC</Text>
          <CardVerificationCodeElement
            ref={cvcRef}
            style={styles.cardElement}
            placeholder="CVC"
          />
        </View>
      </ScrollView>
    </BasisTheoryProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#333',
  },
  section: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  cardElement: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    backgroundColor: '#fff',
    minHeight: 48,
  },
});

export default App;
```

This will create new instances of Card Elements that will render secure input fields for capturing payment data. The Basis Theory SDK will hold references to the Card Elements which enables interactions with the underlying data without direct access to the values.

We are also leveraging [Refs](https://react.dev/learn/referencing-values-with-refs) to hold references to our Card Elements.

## Step 6: Encrypt and Submit Card Data

We want to encrypt the card data before sending it to our backend. We need to add a submit button and a handler that encrypts the underlying data.

We also want to display the result by adding state to hold the response.

```tsx showLineNumbers title="App.tsx"
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  ScrollView,
} from 'react-native';
import {
  BasisTheoryProvider,
  CardNumberElement,
  CardExpirationDateElement,
  CardVerificationCodeElement,
} from '@basis-theory/basis-theory-react-native';

// Your encryption key details from Step 1
const encryptionKeyId = 'b1e2c3d4-5678-1234-9abc-def012345678';
const publicKeyPEM = `-----BEGIN PUBLIC KEY-----
WQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=
-----END PUBLIC KEY-----`;

function App(): JSX.Element {
  const { bt } = useBasisTheory('<PUBLIC_API_KEY>');
  const [customerName, setCustomerName] = useState('');
  const [result, setResult] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  // Refs for Elements
  const cardNumberRef = useRef(null);
  const expirationDateRef = useRef(null);
  const cvcRef = useRef(null);

  const handleSubmit = async () => {
    if (!bt || !cardNumberRef.current || !expirationDateRef.current || !cvcRef.current) {
      Alert.alert('Error', 'Payment form not properly initialized');
      return;
    }

    setIsLoading(true);
    setResult('Encrypting payment data...');

    try {
      // Create the token payload that will be encrypted
      const tokenPayload = {
        type: 'card',
        data: {
          number: cardNumberRef.current,
          expiration_month: expirationDateRef.current,
          expiration_year: expirationDateRef.current,
          cvc: cvcRef.current,
        },
        metadata: {
          cardholder_name: customerName,
          source: 'react_native_encrypted',
        },
      };

      // Encrypt the payload using the public key
      const encryptedPayload = await bt.encrypt({
        payload: tokenPayload,
        publicKey: publicKeyPEM,
        keyId: encryptionKeyId,
      });

      // Send encrypted payload to backend
      const response = await sendToBackend(encryptedPayload, customerName);
      
      setResult(`✓ Payment data encrypted successfully!\n\nResponse: ${JSON.stringify(response, null, 2)}`);
      
      // Reset form
      setCustomerName('');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Encryption failed';
      setResult(`✗ Encryption failed: ${errorMessage}`);
      Alert.alert('Error', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const sendToBackend = async (encryptedPayload: string, customerName: string) => {
    // This would typically be an HTTP request to your backend
    // For demonstration purposes, we'll simulate a successful response
    return {
      success: true,
      tokenId: 'token_123456',
      message: 'Payment processed successfully',
    };
  };

  return (
    <BasisTheoryProvider bt={bt}>
      <ScrollView style={styles.container}>
        <Text style={styles.title}>Client-Side Encryption Demo</Text>
        
        <View style={styles.section}>
          <Text style={styles.label}>Cardholder Name</Text>
          <TextInput
            style={styles.input}
            placeholder="John Doe"
            value={customerName}
            onChangeText={setCustomerName}
            editable={!isLoading}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>Card Number</Text>
          <CardNumberElement
            ref={cardNumberRef}
            style={styles.cardElement}
            placeholder="Card Number"
            disabled={isLoading}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>Expiration Date</Text>
          <CardExpirationDateElement
            ref={expirationDateRef}
            style={styles.cardElement}
            placeholder="MM/YY"
            disabled={isLoading}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>CVC</Text>
          <CardVerificationCodeElement
            ref={cvcRef}
            style={styles.cardElement}
            placeholder="CVC"
            disabled={isLoading}
          />
        </View>

        <TouchableOpacity
          style={[
            styles.submitButton,
            isLoading && styles.submitButtonDisabled,
          ]}
          onPress={handleSubmit}
          disabled={isLoading}
        >
          <Text style={styles.submitButtonText}>
            {isLoading ? 'Encrypting...' : 'Encrypt and Submit'}
          </Text>
        </TouchableOpacity>

        {result ? (
          <View style={styles.resultContainer}>
            <Text style={styles.resultText}>{result}</Text>
          </View>
        ) : null}
      </ScrollView>
    </BasisTheoryProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#333',
  },
  section: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  cardElement: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    backgroundColor: '#fff',
    minHeight: 48,
  },
  submitButton: {
    backgroundColor: '#007bff',
    borderRadius: 12,
    padding: 15,
    alignItems: 'center',
    marginTop: 20,
  },
  submitButtonDisabled: {
    backgroundColor: '#6c757d',
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  resultContainer: {
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    padding: 15,
    marginTop: 20,
  },
  resultText: {
    fontSize: 12,
    color: '#333',
    fontFamily: 'Courier',
  },
});

export default App;
```

When our form is submitted, Basis Theory's SDK will encrypt the Element values using the provided public key. This will be securely encrypted directly in the React Native app. The resulting encrypted payload can then be safely sent to your backend for token creation.

## Step 7: Handle Encrypted Payloads in Your Backend

Your backend receives the encrypted payloads and creates tokens using the encrypted data.

<Tabs className="bt-tabs" groupId="languages">
  <TabItem value="node" label="Node.js (Express)">

```javascript title="server.js"
const express = require('express');
const { BasisTheory } = require('@basis-theory/basis-theory-js');

const app = express();
app.use(express.json());

// Initialize Basis Theory with your Private Application key
const bt = new BasisTheory('<PRIVATE_API_KEY>');

app.post('/api/process-encrypted-payment', async (req, res) => {
    try {
        const { encryptedPayload, customerName } = req.body;

        console.log('Processing encrypted payment for:', customerName);

        // Create token using encrypted payload
        const token = await bt.tokens.create({
            type: 'card',
            encrypted: encryptedPayload,
            metadata: {
                customer_name: customerName,
                processed_at: new Date().toISOString()
            }
        });

        console.log('Token created:', token.id);

        res.json({
            success: true,
            tokenId: token.id,
            message: 'Payment processed successfully'
        });

    } catch (error) {
        console.error('Error processing encrypted payment:', error);
        
        res.status(500).json({
            success: false,
            error: error.message || 'Payment processing failed'
        });
    }
});

app.listen(3001, () => {
    console.log('Server running on port 3001');
});
```

  </TabItem>
  <TabItem value="expo" label="Expo API Route">

```typescript title="app/api/process-encrypted-payment+api.ts"
import { BasisTheory } from '@basis-theory/basis-theory-js';

const bt = new BasisTheory(process.env.PRIVATE_API_KEY!);

export async function POST(request: Request) {
  try {
    const { encryptedPayload, customerName } = await request.json();

    console.log('Processing encrypted payment for:', customerName);

    // Create token using encrypted payload
    const token = await bt.tokens.create({
      type: 'card',
      encrypted: encryptedPayload,
      metadata: {
        customer_name: customerName,
        processed_at: new Date().toISOString()
      }
    });

    console.log('Token created:', token.id);

    return Response.json({
      success: true,
      tokenId: token.id,
      message: 'Payment processed successfully'
    });

  } catch (error) {
    console.error('Error processing encrypted payment:', error);
    
    return Response.json({
      success: false,
      error: error instanceof Error ? error.message : 'Payment processing failed'
    }, { status: 500 });
  }
}
```

  </TabItem>
</Tabs>

## Running the Example

🎉 The code above is the last bit that we need to encrypt! Now let's run the app by running the following commands:

### Start Metro bundler
```bash
npx react-native start
```

### Run on iOS
```bash
npx react-native run-ios
```

### Run on Android
```bash
npx react-native run-android
```

### Test the Encryption Flow

1. **Load the app**: Elements should render without errors
2. **Enter card details**: Use test card number `4242424242424242`
3. **Submit form**: Should show "Encrypting..." then success message
4. **Check result**: Should display the encrypted payload processing result

### Test Card Numbers

Use these test card numbers for development:

| Card Number | Brand | Description |
|-------------|-------|-------------|
| 4242424242424242 | Visa | Valid card for testing |
| 5555555555554444 | Mastercard | Valid card for testing |
| 378282246310005 | American Express | Valid card for testing |

## Platform-Specific Considerations

### iOS Configuration

```xml title="ios/YourApp/Info.plist"
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <false/>
    <key>NSExceptionDomains</key>
    <dict>
        <key>api.basistheory.com</key>
        <dict>
            <key>NSExceptionRequiresForwardSecrecy</key>
            <false/>
            <key>NSExceptionMinimumTLSVersion</key>
            <string>TLSv1.2</string>
        </dict>
    </dict>
</dict>
```

### Android Configuration

```xml title="android/app/src/main/res/xml/network_security_config.xml"
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config>
        <domain includeSubdomains="true">api.basistheory.com</domain>
        <trust-anchors>
            <certificates src="system"/>
        </trust-anchors>
    </domain-config>
</network-security-config>
```

## Error Handling

### Common Errors and Solutions

**"bt is undefined"**
- Ensure component is wrapped in `BasisTheoryProvider`
- Check that the provider has the correct API key
- Verify the provider is mounted before child components

**"Elements not rendering"**
- Verify refs are properly attached
- Check for console errors during mount
- Ensure Elements are inside BasisTheoryProvider

**"Unable to decrypt token"**
- The encrypted data is malformed or cannot be decrypted
- Check that your Public API key is correct

**"Unrecognized client encryption key"**
- The key used for encryption has been deleted or expired

## Conclusion

You can now capture and encrypt sensitive card data in your React Native application without your app accessing the underlying values, drastically reducing compliance and regulatory scope.

To test, type in card details in the Card Elements and tap on "Encrypt and Submit". Basis Theory's React Native SDK will encrypt the Element values using the provided public key. This will be securely encrypted directly in the app. The resulting encrypted payload can be safely transmitted and processed by your server infrastructure.

## Learn More

- [Client Encryption Keys API](/docs/api/client-keys)
- [What are tokens?](/docs/concepts/what-are-tokens)
- [Encrypt data from Web](/docs/guides/encrypt/encrypt-data-from-web)