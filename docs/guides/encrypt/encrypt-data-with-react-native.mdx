---
title: Encrypt Data with React Native
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { Alert, Alerts } from "@site/src/components/shared/Alert";

# Encrypt Data with React Native

This guide shows you how to implement client-side encryption in React Native applications using Basis Theory Elements. You'll learn to encrypt sensitive data in React Native and send encrypted payloads to your backend for tokenization.

## What You'll Build

- A React Native payment form that encrypts card data before submission
- Cross-platform encryption that works on both iOS and Android
- Encrypted payloads sent to your backend instead of plaintext
- Immediate user feedback while tokenization happens asynchronously

## Before You Begin

You'll need:
- React Native 0.68 or later
- Node.js 16 or later
- A Basis Theory account with a **Public Application** for frontend encryption
- A **Management Application** for creating encryption keys
- A backend service to handle encrypted payloads and tokenization

## Step 1: Install Dependencies

Install the Basis Theory React Native SDK and required dependencies.

```bash
npm install @basis-theory/basis-theory-react-native @basis-theory/basis-theory-js
```

### iOS Setup

```bash
cd ios && pod install
```

### Android Setup

No additional setup required for Android.

## Step 2: Generate Client Encryption Keys

Create encryption keys using your Management Application.

```bash
curl -X POST "https://api.basistheory.com/keys" \
  -H "BT-API-KEY: <MANAGEMENT_API_KEY>" \
  -H "Content-Type: application/json" \
  -d '{
    "expires_at": "2025-12-31T23:59:59Z"
  }'
```

## Step 3: Configure Encryption Settings

Create a configuration module to manage your encryption keys.

```typescript title="src/config/encryption.ts"
export const EncryptionConfig = {
  publicApiKey: '<PUBLIC_API_KEY>',
  encryptionKeyId: 'b1e2c3d4-5678-1234-9abc-def012345678',
  publicKeyPEM: `-----BEGIN PUBLIC KEY-----
WQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=
-----END PUBLIC KEY-----`,
};

export const getEnvironmentConfig = () => {
  const isDevelopment = __DEV__;
  
  return {
    apiKey: isDevelopment 
      ? process.env.BT_PUBLIC_KEY_DEV 
      : process.env.BT_PUBLIC_KEY_PROD,
    keyId: isDevelopment 
      ? process.env.BT_ENCRYPTION_KEY_ID_DEV 
      : process.env.BT_ENCRYPTION_KEY_ID_PROD,
    publicKeyPEM: isDevelopment 
      ? process.env.BT_PUBLIC_KEY_PEM_DEV 
      : process.env.BT_PUBLIC_KEY_PEM_PROD,
  };
};
```

## Step 4: Create Encryption Hook

Build a custom hook to manage encryption functionality.

```typescript title="src/hooks/useEncryption.ts"
import { useState, useCallback } from 'react';
import { BasisTheory } from '@basis-theory/basis-theory-js';
import { EncryptionConfig } from '../config/encryption';

interface EncryptionState {
  isEncrypting: boolean;
  error: string | null;
  success: boolean;
}

interface EncryptionResult {
  encryptedPayload: string;
  success: boolean;
}

export const useEncryption = () => {
  const [state, setState] = useState<EncryptionState>({
    isEncrypting: false,
    error: null,
    success: false,
  });

  const encryptTokenPayload = useCallback(async (
    tokenPayload: any
  ): Promise<EncryptionResult> => {
    setState(prev => ({ ...prev, isEncrypting: true, error: null }));

    try {
      const bt = new BasisTheory(EncryptionConfig.publicApiKey);
      
      const encryptedPayload = await bt.encrypt({
        payload: tokenPayload,
        publicKey: EncryptionConfig.publicKeyPEM,
        keyId: EncryptionConfig.encryptionKeyId,
      });

      setState(prev => ({ 
        ...prev, 
        isEncrypting: false, 
        success: true 
      }));

      return {
        encryptedPayload,
        success: true,
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Encryption failed';
      setState(prev => ({ 
        ...prev, 
        isEncrypting: false, 
        error: errorMessage 
      }));
      
      throw error;
    }
  }, []);

  const resetState = useCallback(() => {
    setState({
      isEncrypting: false,
      error: null,
      success: false,
    });
  }, []);

  return {
    ...state,
    encryptTokenPayload,
    resetState,
  };
};
```

## Step 5: Create Payment Form Component

Build a React Native component that collects card data and encrypts it.

```typescript title="src/components/PaymentForm.tsx"
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
  StyleSheet,
  ScrollView,
} from 'react-native';
import {
  BasisTheoryProvider,
  CardNumberElement,
  CardExpirationDateElement,
  CardVerificationCodeElement,
} from '@basis-theory/basis-theory-react-native';
import { useEncryption } from '../hooks/useEncryption';
import { EncryptionConfig } from '../config/encryption';

interface CustomerInfo {
  name: string;
  email: string;
}

interface PaymentFormState {
  customerInfo: CustomerInfo;
  isSubmitting: boolean;
  submitError: string | null;
  submitSuccess: boolean;
}

const PaymentForm: React.FC = () => {
  const { isEncrypting, error: encryptionError, encryptTokenPayload, resetState } = useEncryption();
  
  const [formState, setFormState] = useState<PaymentFormState>({
    customerInfo: { name: '', email: '' },
    isSubmitting: false,
    submitError: null,
    submitSuccess: false,
  });

  // Refs for Elements
  const cardNumberRef = useRef(null);
  const expirationDateRef = useRef(null);
  const cvcRef = useRef(null);

  const handleCustomerInfoChange = (field: keyof CustomerInfo, value: string) => {
    setFormState(prev => ({
      ...prev,
      customerInfo: {
        ...prev.customerInfo,
        [field]: value,
      },
    }));
  };

  const handleSubmit = async () => {
    if (!cardNumberRef.current || !expirationDateRef.current || !cvcRef.current) {
      Alert.alert('Error', 'Payment form not properly initialized');
      return;
    }

    setFormState(prev => ({ 
      ...prev, 
      isSubmitting: true, 
      submitError: null,
      submitSuccess: false 
    }));
    resetState();

    try {
      // Create the token payload that will be encrypted
      const tokenPayload = {
        type: 'card',
        data: {
          number: cardNumberRef.current,
          expiration_month: expirationDateRef.current,
          expiration_year: expirationDateRef.current,
          cvc: cvcRef.current,
        },
        metadata: {
          customer_name: formState.customerInfo.name,
          customer_email: formState.customerInfo.email,
          source: 'react_native_encrypted',
        },
      };

      // Encrypt the payload
      const { encryptedPayload } = await encryptTokenPayload(tokenPayload);

      // Send to backend
      await sendToBackend(encryptedPayload, formState.customerInfo);

      setFormState(prev => ({ 
        ...prev, 
        isSubmitting: false,
        submitSuccess: true,
        customerInfo: { name: '', email: '' }, // Reset form
      }));

      Alert.alert('Success', 'Payment processed successfully!');

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Payment processing failed';
      setFormState(prev => ({ 
        ...prev, 
        isSubmitting: false, 
        submitError: errorMessage 
      }));
      
      Alert.alert('Error', errorMessage);
    }
  };

  const sendToBackend = async (encryptedPayload: string, customerInfo: CustomerInfo) => {
    const response = await fetch('https://your-api.com/api/process-encrypted-payment', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        encryptedPayload,
        customerInfo,
      }),
    });

    if (!response.ok) {
      throw new Error(`Backend error: ${response.status}`);
    }

    return response.json();
  };

  const isProcessing = isEncrypting || formState.isSubmitting;
  const hasError = encryptionError || formState.submitError;

  return (
    <BasisTheoryProvider apiKey={EncryptionConfig.publicApiKey}>
      <ScrollView style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>Payment Information</Text>
          
          {/* Customer Information */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Customer Details</Text>
            
            <TextInput
              style={styles.input}
              placeholder="Full Name"
              value={formState.customerInfo.name}
              onChangeText={(value) => handleCustomerInfoChange('name', value)}
              editable={!isProcessing}
            />
            
            <TextInput
              style={styles.input}
              placeholder="Email"
              value={formState.customerInfo.email}
              onChangeText={(value) => handleCustomerInfoChange('email', value)}
              keyboardType="email-address"
              autoCapitalize="none"
              editable={!isProcessing}
            />
          </View>

          {/* Card Information */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Card Details</Text>
            
            <CardNumberElement
              ref={cardNumberRef}
              style={styles.cardElement}
              placeholder="Card Number"
              disabled={isProcessing}
            />

            <View style={styles.row}>
              <CardExpirationDateElement
                ref={expirationDateRef}
                style={[styles.cardElement, styles.halfWidth]}
                placeholder="MM/YY"
                disabled={isProcessing}
              />

              <CardVerificationCodeElement
                ref={cvcRef}
                style={[styles.cardElement, styles.halfWidth]}
                placeholder="CVC"
                disabled={isProcessing}
              />
            </View>
          </View>

          {/* Submit Button */}
          <TouchableOpacity
            style={[
              styles.submitButton,
              isProcessing && styles.submitButtonDisabled,
            ]}
            onPress={handleSubmit}
            disabled={isProcessing}
          >
            <View style={styles.submitButtonContent}>
              {isProcessing && (
                <ActivityIndicator 
                  size="small" 
                  color="#fff" 
                  style={styles.spinner} 
                />
              )}
              <Text style={styles.submitButtonText}>
                {isEncrypting ? 'Encrypting...' : 
                 formState.isSubmitting ? 'Processing...' : 
                 'Encrypt and Submit Payment'}
              </Text>
            </View>
          </TouchableOpacity>

          {/* Status Messages */}
          {hasError && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>✗ {hasError}</Text>
            </View>
          )}

          {formState.submitSuccess && (
            <View style={styles.successContainer}>
              <Text style={styles.successText}>
                ✓ Payment data encrypted and processed successfully!
              </Text>
            </View>
          )}
        </View>
      </ScrollView>
    </BasisTheoryProvider>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#333',
  },
  section: {
    marginBottom: 30,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 15,
    color: '#555',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
    marginBottom: 12,
  },
  cardElement: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    backgroundColor: '#fff',
    marginBottom: 12,
    minHeight: 48,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  halfWidth: {
    width: '48%',
  },
  submitButton: {
    backgroundColor: '#007bff',
    borderRadius: 12,
    padding: 15,
    alignItems: 'center',
    marginTop: 20,
  },
  submitButtonDisabled: {
    backgroundColor: '#6c757d',
  },
  submitButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  spinner: {
    marginRight: 8,
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  errorContainer: {
    backgroundColor: '#f8d7da',
    borderColor: '#f5c6cb',
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginTop: 15,
  },
  errorText: {
    color: '#721c24',
    fontSize: 14,
  },
  successContainer: {
    backgroundColor: '#d4edda',
    borderColor: '#c3e6cb',
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginTop: 15,
  },
  successText: {
    color: '#155724',
    fontSize: 14,
  },
});

export default PaymentForm;
```

## Step 6: Handle Encrypted Payloads in Your Backend

Your backend receives encrypted payloads and creates tokens using the same approach as shown in other platform guides.

## Step 7: Test Your Implementation

### Development Testing

1. **Start Metro bundler**: `npx react-native start`
2. **Run on iOS**: `npx react-native run-ios`
3. **Run on Android**: `npx react-native run-android`
4. **Fill out the form** with test data
5. **Submit and verify** encryption works correctly

### Test Card Numbers

| Card Number | Brand | Description |
|-------------|-------|-------------|
| 4242424242424242 | Visa | Valid card for testing |
| 5555555555554444 | Mastercard | Valid card for testing |
| 378282246310005 | American Express | Valid card for testing |

## Platform-Specific Considerations

### iOS Configuration

```xml title="ios/YourApp/Info.plist"
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <false/>
    <key>NSExceptionDomains</key>
    <dict>
        <key>api.basistheory.com</key>
        <dict>
            <key>NSExceptionRequiresForwardSecrecy</key>
            <false/>
            <key>NSExceptionMinimumTLSVersion</key>
            <string>TLSv1.2</string>
            <key>NSThirdPartyExceptionRequiresForwardSecrecy</key>
            <false/>
        </dict>
    </dict>
</dict>
```

### Android Configuration

```xml title="android/app/src/main/res/xml/network_security_config.xml"
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config>
        <domain includeSubdomains="true">api.basistheory.com</domain>
        <trust-anchors>
            <certificates src="system"/>
        </trust-anchors>
    </domain-config>
</network-security-config>
```

## Error Handling Best Practices

### Network Error Handling

```typescript title="src/utils/errorHandler.ts"
export const handleNetworkError = (error: any): string => {
  if (error.code === 'NETWORK_ERROR') {
    return 'No internet connection. Please check your network.';
  }
  
  if (error.code === 'TIMEOUT') {
    return 'Request timed out. Please try again.';
  }
  
  if (error.status >= 500) {
    return 'Server error. Please try again later.';
  }
  
  return error.message || 'An unexpected error occurred.';
};
```

### Form Validation

```typescript title="src/utils/validation.ts"
export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const validateCardNumber = (cardNumber: string): boolean => {
  const cleaned = cardNumber.replace(/\s/g, '');
  return cleaned.length >= 13 && cleaned.length <= 19 && /^\d+$/.test(cleaned);
};

export const validateForm = (customerInfo: CustomerInfo): string[] => {
  const errors: string[] = [];
  
  if (!customerInfo.name.trim()) {
    errors.push('Customer name is required');
  }
  
  if (!validateEmail(customerInfo.email)) {
    errors.push('Valid email address is required');
  }
  
  return errors;
};
```

## Production Considerations

### Environment Variables

```bash title=".env"
BT_PUBLIC_KEY_DEV=key_dev_...
BT_PUBLIC_KEY_PROD=key_live_...
BT_ENCRYPTION_KEY_ID_DEV=dev-key-id
BT_ENCRYPTION_KEY_ID_PROD=prod-key-id
```

### Performance Optimization

- Use `React.memo` for expensive components
- Implement lazy loading for large forms
- Cache encryption configurations
- Optimize bundle size with proper imports

### Security Best Practices

- Store sensitive configuration in secure storage
- Implement certificate pinning for production
- Use proper error handling without exposing sensitive data
- Validate all inputs on both client and server

## Next Steps

### Advanced Features
- Add biometric authentication support
- Implement offline support with encrypted storage
- Add comprehensive form validation
- Integrate with platform-specific payment methods

### Testing and Deployment
- Implement unit and integration tests
- Set up CI/CD pipelines for both platforms
- Configure code signing and app store deployment
- Monitor encryption success rates and performance

For complete examples and advanced patterns, visit our [React Native encryption examples repository](https://github.com/Basis-Theory/react-native-encryption-examples). 