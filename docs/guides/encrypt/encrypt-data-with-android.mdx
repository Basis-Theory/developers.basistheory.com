---
title: Encrypt Data with Android
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { Alert, Alerts } from "@site/src/components/shared/Alert";
import { AuthButtons } from "@site/src/components/docs/AuthButtons";

# Encrypt Data with Android

This guide will show you how to implement client-side encryption in Android applications using Basis Theory Elements. You'll learn to encrypt sensitive data in Android and send encrypted payloads to your backend for tokenization.

Key concepts in this guide:

- [Client Encryption Keys](/docs/api/client-keys)
- [Android Elements](/docs/sdks/mobile/android)
- [Tokens](/docs/concepts/what-are-tokens)
- [Applications](/docs/api/applications)

## What You'll Build

By the end of this guide, you'll have:
- An Android payment form that encrypts card data before submission
- Encrypted payloads sent to your backend instead of plaintext
- Immediate user feedback while tokenization happens asynchronously
- Secure handling of encryption keys and sensitive data

## Getting Started

To get started, you will need a Basis Theory account.

<AuthButtons />

Next, you will need two applications:

1. **Management Application** - to create encryption keys
2. **Public Application** - to initialize Elements for your Android app

### Management Application

[Click here](https://portal.basistheory.com/applications/create?name=Encryption%20Key%20Manager&type=management&permissions=key%3Acreate) to create a Management Application or [login to your Basis Theory account](https://portal.basistheory.com/applications) and create a new application with the following settings:

- Name - Encryption Key Manager
- Application Type - Management
- Permissions - `key:create`

<Alert>Save the API Key from the created Management Application as it will be used to create encryption keys.</Alert>

### Public Application

[Click here](https://portal.basistheory.com/applications/create?permissions=&type=public&name=Encrypt%20Data%20with%20Android%20Guide) to create a Public Application or [login to your Basis Theory account](https://portal.basistheory.com/applications) and create a new application with the following settings:

- Name - Encrypt Data with Android Guide
- Application Type - Public
- Permissions - (none required for client-side encryption)

<Alert>Save the API Key from the created Public Application as it will be used later in this guide to initialize the form.</Alert>

## Step 1: Generate Client Encryption Keys

Create encryption keys using your Management Application. These keys enable client-side encryption.

```bash
curl -X POST "https://api.basistheory.com/keys" \
  -H "BT-API-KEY: <MANAGEMENT_API_KEY>" \
  -H "Content-Type: application/json" \
  -d '{
    "expires_at": "2025-12-31T23:59:59Z"
  }'
```

<Alert>Be sure to replace <code>&lt;MANAGEMENT_API_KEY></code> with the Management API Key you created in the <a href="#getting-started">Getting Started</a> step.</Alert>

**Expected Response:**
```json
{
  "id": "b1e2c3d4-5678-1234-9abc-def012345678",
  "publicKeyPEM": "-----BEGIN PUBLIC KEY-----\nWQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=\n-----END PUBLIC KEY-----",
  "expires_at": "2025-12-31T23:59:59Z"
}
```

<Alert type={Alerts.WARNING}>Save the public key (<code>publicKeyPEM</code>) and key ID (<code>id</code>) - you'll need both for client-side encryption. The public key is only returned when creating a key. Make sure to securely store it, as you won't be able to retrieve it later.</Alert>

## Step 2: Set Up the Project

We will create a new Android application through Android Studio. If you don't have Android Studio, download it [here](https://developer.android.com/studio).

1. Launch Android Studio, then click `New Project`. On the `Phone and Tablet` tab select `Empty Activity` and click `Next`.

2. For the `Name` enter "Android Encrypt Guide", and for the `Package name` use your organization's name. Leave the remaining settings as is and click `Finish`.

This will launch Android Studio with the newly created project. Wait a bit for it to set up and Gradle sync to finish.

## Step 3: Install the Android Elements SDK

We will need to install Basis Theory's [Android Elements SDK](/docs/sdks/mobile/android), which will be used to render secure Elements for capturing data and provide encryption capabilities.

In the settings.gradle file add this repository:

```groovy
repositories {
    maven { url 'https://jitpack.io' }
}
```

Then in the build.gradle add this dependency specifying the correct version:

```groovy
dependencies {
    implementation 'com.github.basis-theory:basistheory-android:<version>'
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4'
}
```

## Step 4: Add Your Form Elements

Now we need to add [Card Elements](/docs/sdks/mobile/android/types#cardnumberelement) to our application for collecting payment card data.

To do so, open the `res/layout/activity_main.xml` file and add the following code:

```xml showLineNumbers
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_margin="20dp"
            android:orientation="vertical">

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Client-Side Encryption Demo"
                android:textSize="20sp"
                android:textStyle="bold"
                android:layout_marginBottom="20dp" />

            <EditText
                android:id="@+id/customer_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Cardholder Name"
                android:layout_marginBottom="10dp" />

            <com.basistheory.android.view.CardNumberElement
                android:id="@+id/card_number"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp" />

            <com.basistheory.android.view.CardExpirationDateElement
                android:id="@+id/expiration_date"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp" />

            <com.basistheory.android.view.CardVerificationCodeElement
                android:id="@+id/cvc"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp" />

            <Button
                android:id="@+id/encrypt_button"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:backgroundTint="#00A4BA"
                android:text="Encrypt and Submit" />

            <TextView
                android:id="@+id/result_text"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="20dp"
                android:background="#f8f9fa"
                android:padding="10dp"
                android:textSize="12sp"
                android:visibility="gone" />

        </LinearLayout>
    </ScrollView>

</androidx.constraintlayout.widget.ConstraintLayout>
```

This adds a form layout with cardholder name input, card number element, expiration date element, CVC element, and a button used to encrypt and submit the payment data.

## Step 5: Configure Elements and Variables

Now it's time to set up our Android activity. We'll be configuring our elements and declaring the necessary variables.

Open your main activity class file which should be called `MainActivity.kt`. Now we need to declare and initialize variables to reference the elements we defined in the layout.

```kotlin showLineNumbers
import android.graphics.Color
import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.basistheory.android.BasisTheoryElements
import com.basistheory.android.view.CardNumberElement
import com.basistheory.android.view.CardExpirationDateElement
import com.basistheory.android.view.CardVerificationCodeElement
import kotlinx.coroutines.launch

class MainActivity : AppCompatActivity() {

    // Form element references
    private lateinit var customerNameInput: EditText
    private lateinit var cardNumberElement: CardNumberElement
    private lateinit var expirationDateElement: CardExpirationDateElement
    private lateinit var cvcElement: CardVerificationCodeElement
    private lateinit var encryptButton: Button
    private lateinit var resultText: TextView

    // Encryption configuration from Step 1
    private val encryptionKeyId = "b1e2c3d4-5678-1234-9abc-def012345678"
    private val publicKeyPEM = """
        -----BEGIN PUBLIC KEY-----
        WQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=
        -----END PUBLIC KEY-----
    """.trimIndent()

    // Initialize Basis Theory with your Public API key
    private val bt = BasisTheoryElements.builder()
        .apiKey("<PUBLIC_API_KEY>")
        .build()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Initialize form elements
        customerNameInput = findViewById(R.id.customer_name)
        cardNumberElement = findViewById(R.id.card_number)
        expirationDateElement = findViewById(R.id.expiration_date)
        cvcElement = findViewById(R.id.cvc)
        encryptButton = findViewById(R.id.encrypt_button)
        resultText = findViewById(R.id.result_text)
    }
}
```

<Alert>Be sure to replace <code>&lt;PUBLIC_API_KEY></code> with the Public API Key you created in the <a href="#getting-started">Getting Started</a> step, and update the encryption key details with your actual key ID and public key PEM.</Alert>

## Step 6: Style Your Form Elements

With the element references declared, we can now style them. Add the following styling code to the `onCreate` method:

```kotlin showLineNumbers
class MainActivity : AppCompatActivity() {

    // ... previous code ...

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Initialize form elements
        customerNameInput = findViewById(R.id.customer_name)
        cardNumberElement = findViewById(R.id.card_number)
        expirationDateElement = findViewById(R.id.expiration_date)
        cvcElement = findViewById(R.id.cvc)
        encryptButton = findViewById(R.id.encrypt_button)
        resultText = findViewById(R.id.result_text)

        // Style the Elements
        cardNumberElement.setPadding(15, 15, 15, 15)
        cardNumberElement.hint = "Card Number"
        cardNumberElement.textColor = Color.BLACK
        cardNumberElement.background = Color.WHITE.toDrawable()

        expirationDateElement.setPadding(15, 15, 15, 15)
        expirationDateElement.hint = "MM/YY"
        expirationDateElement.textColor = Color.BLACK
        expirationDateElement.background = Color.WHITE.toDrawable()

        cvcElement.setPadding(15, 15, 15, 15)
        cvcElement.hint = "CVC"
        cvcElement.textColor = Color.BLACK
        cvcElement.background = Color.WHITE.toDrawable()
    }
}
```

## Step 7: Encrypt and Submit Card Data

We want to encrypt the card data before sending it to our backend. Let's add the encryption functionality.

Just like we did with the other elements, let's add a click listener to the button that will encrypt the payment data:

```kotlin showLineNumbers
class MainActivity : AppCompatActivity() {

    // ... previous code ...

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Initialize form elements
        customerNameInput = findViewById(R.id.customer_name)
        cardNumberElement = findViewById(R.id.card_number)
        expirationDateElement = findViewById(R.id.expiration_date)
        cvcElement = findViewById(R.id.cvc)
        encryptButton = findViewById(R.id.encrypt_button)
        resultText = findViewById(R.id.result_text)

        // Style the Elements
        cardNumberElement.setPadding(15, 15, 15, 15)
        cardNumberElement.hint = "Card Number"
        cardNumberElement.textColor = Color.BLACK
        cardNumberElement.background = Color.WHITE.toDrawable()

        expirationDateElement.setPadding(15, 15, 15, 15)
        expirationDateElement.hint = "MM/YY"
        expirationDateElement.textColor = Color.BLACK
        expirationDateElement.background = Color.WHITE.toDrawable()

        cvcElement.setPadding(15, 15, 15, 15)
        cvcElement.hint = "CVC"
        cvcElement.textColor = Color.BLACK
        cvcElement.background = Color.WHITE.toDrawable()

        // Set up encrypt button listener
        encryptButton.setOnClickListener {
            encryptAndSubmit()
        }
    }

    private fun encryptAndSubmit() {
        lifecycleScope.launch {
            try {
                // Disable button during processing
                encryptButton.isEnabled = false
                encryptButton.text = "Encrypting..."
                resultText.visibility = TextView.VISIBLE
                resultText.text = "Encrypting payment data..."

                val customerName = customerNameInput.text.toString()

                // Create the token payload that will be encrypted
                val tokenPayload = object {
                    val type = "card"
                    val data = object {
                        val number = cardNumberElement
                        val expiration_month = expirationDateElement
                        val expiration_year = expirationDateElement
                        val cvc = cvcElement
                    }
                    val metadata = object {
                        val cardholder_name = customerName
                        val source = "android_encrypted"
                    }
                }

                // Encrypt the payload using the public key
                val encryptedPayload = bt.encrypt(
                    payload = tokenPayload,
                    publicKey = publicKeyPEM,
                    keyId = encryptionKeyId
                )

                // Send encrypted payload to backend
                val response = sendToBackend(encryptedPayload, customerName)
                
                resultText.text = "✓ Payment data encrypted successfully!\n\nResponse: $response"
                
                // Reset form
                customerNameInput.text.clear()
                
            } catch (e: Exception) {
                resultText.text = "✗ Encryption failed: ${e.message}"
            } finally {
                // Re-enable button
                encryptButton.isEnabled = true
                encryptButton.text = "Encrypt and Submit"
            }
        }
    }

    private suspend fun sendToBackend(encryptedPayload: String, customerName: String): String {
        // This would typically be an HTTP request to your backend
        // For demonstration purposes, we'll simulate a successful response
        return """
            {
              "success": true,
              "tokenId": "token_123456",
              "message": "Payment processed successfully"
            }
        """.trimIndent()
    }
}
```

When our form is submitted, Basis Theory's SDK will encrypt the Element values using the provided public key. This will be securely encrypted directly in the Android app. The resulting encrypted payload can then be safely sent to your backend for token creation.

## Step 8: Handle Encrypted Payloads in Your Backend

Your backend receives the encrypted payloads and creates tokens using the encrypted data.

<Tabs className="bt-tabs" groupId="languages">
  <TabItem value="node" label="Node.js (Express)">

```javascript title="server.js"
const express = require('express');
const { BasisTheory } = require('@basis-theory/basis-theory-js');

const app = express();
app.use(express.json());

// Initialize Basis Theory with your Private Application key
const bt = new BasisTheory('<PRIVATE_API_KEY>');

app.post('/api/process-encrypted-payment', async (req, res) => {
    try {
        const { encryptedPayload, customerName } = req.body;

        console.log('Processing encrypted payment for:', customerName);

        // Create token using encrypted payload
        const token = await bt.tokens.create({
            type: 'card',
            encrypted: encryptedPayload,
            metadata: {
                customer_name: customerName,
                processed_at: new Date().toISOString()
            }
        });

        console.log('Token created:', token.id);

        res.json({
            success: true,
            tokenId: token.id,
            message: 'Payment processed successfully'
        });

    } catch (error) {
        console.error('Error processing encrypted payment:', error);
        
        res.status(500).json({
            success: false,
            error: error.message || 'Payment processing failed'
        });
    }
});

app.listen(3001, () => {
    console.log('Server running on port 3001');
});
```

  </TabItem>
  <TabItem value="kotlin" label="Kotlin (Spring Boot)">

```kotlin title="PaymentController.kt"
@RestController
@RequestMapping("/api")
class PaymentController {
    
    @Value("\${basis-theory.private-api-key}")
    private lateinit var privateApiKey: String
    
    @PostMapping("/process-encrypted-payment")
    suspend fun processEncryptedPayment(@RequestBody request: EncryptedPaymentRequest): ResponseEntity<PaymentResponse> {
        return try {
            val bt = BasisTheoryElements.builder()
                .apiKey(privateApiKey)
                .build()
            
            println("Processing encrypted payment for: ${request.customerName}")
            
            // Create token using encrypted payload
            val token = bt.tokenize(object {
                val type = "card"
                val encrypted = request.encryptedPayload
                val metadata = object {
                    val customer_name = request.customerName
                    val processed_at = Instant.now().toString()
                }
            })
            
            println("Token created: ${token.id}")
            
            ResponseEntity.ok(PaymentResponse(
                success = true,
                tokenId = token.id,
                message = "Payment processed successfully"
            ))
            
        } catch (e: Exception) {
            println("Error processing encrypted payment: ${e.message}")
            
            ResponseEntity.status(500).body(PaymentResponse(
                success = false,
                error = e.message ?: "Payment processing failed"
            ))
        }
    }
}

data class EncryptedPaymentRequest(
    val encryptedPayload: String,
    val customerName: String
)

data class PaymentResponse(
    val success: Boolean,
    val tokenId: String? = null,
    val message: String? = null,
    val error: String? = null
)
```

  </TabItem>
</Tabs>

### Test the Encryption Flow

1. **Load the app**: Elements should render without errors
2. **Enter card details**: Use test card number `4242424242424242`
3. **Submit form**: Should show "Encrypting..." then success message
4. **Check result**: Should display the encrypted payload processing result

### Test Card Numbers

Use these test card numbers for development:

| Card Number | Brand | Description |
|-------------|-------|-------------|
| 4242424242424242 | Visa | Valid card for testing |
| 5555555555554444 | Mastercard | Valid card for testing |
| 378282246310005 | American Express | Valid card for testing |

## Error Handling

### Common Errors and Solutions

**"Elements not rendering"**
- Ensure the Elements SDK is properly imported
- Verify that Elements are properly configured

**"Unable to decrypt token"**
- The encrypted data is malformed or cannot be decrypted
- Check that your Public API key is correct

**"Unrecognized client encryption key"**
- The key used for encryption has been deleted or expired

## Security Considerations

### ProGuard Configuration

Add these rules to your `proguard-rules.pro` file to protect Basis Theory classes:

```proguard title="proguard-rules.pro"
# Keep Basis Theory classes
-keep class com.basistheory.** { *; }
-dontwarn com.basistheory.**

# Keep encryption-related classes
-keep class javax.crypto.** { *; }
-keep class java.security.** { *; }
```

### Network Security

Ensure all communications use HTTPS and consider certificate pinning for production apps.

## Conclusion

You can now capture and encrypt sensitive card data in your Android application without your app accessing the underlying values, drastically reducing compliance and regulatory scope.

Try entering card details and tapping the encrypt button to securely encrypt the data directly in the Android app and send encrypted payloads to your backend. The resulting encrypted payload can be safely transmitted and processed by your server infrastructure.

## Learn More

A full example Android application is included within the [example](https://github.com/Basis-Theory/basistheory-android/tree/master/example) module within the GitHub repository or explore all the supported [Element Types](/docs/sdks/mobile/android/types).

- [Client Encryption Keys API](/docs/api/client-keys)
- [What are tokens?](/docs/concepts/what-are-tokens)
- [Encrypt data from Web](/docs/guides/encrypt/encrypt-data-from-web) 