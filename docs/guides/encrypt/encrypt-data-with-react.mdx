---
title: Encrypt Data with React
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { Alert, Alerts } from "@site/src/components/shared/Alert";

# Encrypt Data with React

This guide shows you how to implement client-side encryption in React applications using Basis Theory Elements. You'll learn to encrypt sensitive data in React components and send encrypted payloads to your backend for tokenization.

## What You'll Build

By the end of this guide, you'll have:
- A React payment form that encrypts card data before submission
- Custom hooks for managing encryption keys and state
- Encrypted payloads sent to your backend instead of plaintext
- Immediate user feedback with React state management
- Type-safe implementation with TypeScript support

## Before You Begin

You'll need:
- A React application (Create React App, Next.js, or Vite)
- A Basis Theory account with a **Public Application** for frontend encryption
- A **Management Application** for creating encryption keys
- A backend service to handle encrypted payloads and tokenization
- Basic knowledge of React hooks and components

## Step 1: Install Dependencies

Install the Basis Theory React SDK and required dependencies.

```bash
npm install @basis-theory/basis-theory-react @basis-theory/basis-theory-js
```

For TypeScript projects, the types are included in the packages.

## Step 2: Generate Client Encryption Keys

Create encryption keys using your Management Application. You can do this via API or your dashboard.

```bash
curl -X POST "https://api.basistheory.com/keys" \
  -H "BT-API-KEY: <MANAGEMENT_API_KEY>" \
  -H "Content-Type: application/json" \
  -d '{
    "expires_at": "2025-12-31T23:59:59Z"
  }'
```

**Expected Response:**
```json
{
  "id": "b1e2c3d4-5678-1234-9abc-def012345678",
  "publicKeyPEM": "-----BEGIN PUBLIC KEY-----\nWQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=\n-----END PUBLIC KEY-----",
  "expires_at": "2025-12-31T23:59:59Z"
}
```

## Step 3: Set Up Basis Theory Provider

Wrap your application with the Basis Theory provider to enable Elements and encryption.

```tsx title="src/App.tsx"
import React from 'react';
import { BasisTheoryProvider } from '@basis-theory/basis-theory-react';
import PaymentForm from './components/PaymentForm';

// Your encryption key details from Step 2
export const ENCRYPTION_CONFIG = {
  keyId: 'b1e2c3d4-5678-1234-9abc-def012345678',
  publicKeyPEM: `-----BEGIN PUBLIC KEY-----
WQ4geAENWHyR7+g94nN6lFZzY7YdGWxPtlX/16fJ4z0=
-----END PUBLIC KEY-----`
};

function App() {
  return (
    <BasisTheoryProvider apiKey="<PUBLIC_API_KEY>">
      <div className="App">
        <header className="App-header">
          <h1>Client-Side Encryption Demo</h1>
          <PaymentForm />
        </header>
      </div>
    </BasisTheoryProvider>
  );
}

export default App;
```

## Step 4: Create Custom Encryption Hook

Create a custom hook to manage encryption functionality and state.

```tsx title="src/hooks/useEncryption.ts"
import { useState, useCallback } from 'react';
import { useBasisTheory } from '@basis-theory/basis-theory-react';
import { ENCRYPTION_CONFIG } from '../App';

interface EncryptionState {
  isEncrypting: boolean;
  error: string | null;
  success: boolean;
}

interface EncryptionResult {
  encryptedPayload: string;
  success: boolean;
}

export const useEncryption = () => {
  const { bt } = useBasisTheory();
  const [state, setState] = useState<EncryptionState>({
    isEncrypting: false,
    error: null,
    success: false
  });

  const encryptTokenPayload = useCallback(async (
    tokenPayload: any
  ): Promise<EncryptionResult> => {
    if (!bt) {
      throw new Error('Basis Theory not initialized');
    }

    setState(prev => ({ ...prev, isEncrypting: true, error: null }));

    try {
      // Encrypt the payload using the public key
      const encryptedPayload = await bt.encrypt({
        payload: tokenPayload,
        publicKey: ENCRYPTION_CONFIG.publicKeyPEM,
        keyId: ENCRYPTION_CONFIG.keyId
      });

      setState(prev => ({ 
        ...prev, 
        isEncrypting: false, 
        success: true 
      }));

      return {
        encryptedPayload,
        success: true
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Encryption failed';
      setState(prev => ({ 
        ...prev, 
        isEncrypting: false, 
        error: errorMessage 
      }));
      
      throw error;
    }
  }, [bt]);

  const resetState = useCallback(() => {
    setState({
      isEncrypting: false,
      error: null,
      success: false
    });
  }, []);

  return {
    ...state,
    encryptTokenPayload,
    resetState
  };
};
```

## Step 5: Create Payment Form Component

Build a React component that collects card data and encrypts it before submission.

```tsx title="src/components/PaymentForm.tsx"
import React, { useState, useRef } from 'react';
import {
  CardNumberElement,
  CardExpirationDateElement,
  CardVerificationCodeElement,
  useBasisTheory
} from '@basis-theory/basis-theory-react';
import { useEncryption } from '../hooks/useEncryption';
import './PaymentForm.css';

interface CustomerInfo {
  name: string;
  email: string;
}

interface PaymentFormState {
  customerInfo: CustomerInfo;
  isSubmitting: boolean;
  submitError: string | null;
  submitSuccess: boolean;
}

const PaymentForm: React.FC = () => {
  const { bt } = useBasisTheory();
  const { isEncrypting, error: encryptionError, encryptTokenPayload, resetState } = useEncryption();
  
  const [formState, setFormState] = useState<PaymentFormState>({
    customerInfo: { name: '', email: '' },
    isSubmitting: false,
    submitError: null,
    submitSuccess: false
  });

  // Refs for Elements
  const cardNumberRef = useRef(null);
  const expirationDateRef = useRef(null);
  const cvcRef = useRef(null);

  const handleCustomerInfoChange = (field: keyof CustomerInfo, value: string) => {
    setFormState(prev => ({
      ...prev,
      customerInfo: {
        ...prev.customerInfo,
        [field]: value
      }
    }));
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    
    if (!bt || !cardNumberRef.current || !expirationDateRef.current || !cvcRef.current) {
      setFormState(prev => ({ 
        ...prev, 
        submitError: 'Payment form not properly initialized' 
      }));
      return;
    }

    setFormState(prev => ({ 
      ...prev, 
      isSubmitting: true, 
      submitError: null,
      submitSuccess: false 
    }));
    resetState();

    try {
      // Create the token payload that will be encrypted
      const tokenPayload = {
        type: 'card',
        data: {
          number: cardNumberRef.current,
          expiration_month: expirationDateRef.current,
          expiration_year: expirationDateRef.current,
          cvc: cvcRef.current
        },
        metadata: {
          customer_name: formState.customerInfo.name,
          customer_email: formState.customerInfo.email,
          source: 'react_encrypted'
        }
      };

      // Encrypt the payload
      const { encryptedPayload } = await encryptTokenPayload(tokenPayload);

      // Send to backend
      await sendToBackend(encryptedPayload, formState.customerInfo);

      setFormState(prev => ({ 
        ...prev, 
        isSubmitting: false,
        submitSuccess: true,
        customerInfo: { name: '', email: '' } // Reset form
      }));

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Payment processing failed';
      setFormState(prev => ({ 
        ...prev, 
        isSubmitting: false, 
        submitError: errorMessage 
      }));
    }
  };

  const sendToBackend = async (encryptedPayload: string, customerInfo: CustomerInfo) => {
    const response = await fetch('/api/process-encrypted-payment', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        encryptedPayload,
        customerInfo
      })
    });

    if (!response.ok) {
      throw new Error(`Backend error: ${response.status}`);
    }

    return response.json();
  };

  const isProcessing = isEncrypting || formState.isSubmitting;
  const hasError = encryptionError || formState.submitError;

  return (
    <div className="payment-form-container">
      <form onSubmit={handleSubmit} className="payment-form">
        <h2>Payment Information</h2>
        
        {/* Customer Information */}
        <div className="form-section">
          <h3>Customer Details</h3>
          <div className="form-group">
            <label htmlFor="customer-name">Full Name</label>
            <input
              id="customer-name"
              type="text"
              value={formState.customerInfo.name}
              onChange={(e) => handleCustomerInfoChange('name', e.target.value)}
              required
              disabled={isProcessing}
              className="form-input"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="customer-email">Email</label>
            <input
              id="customer-email"
              type="email"
              value={formState.customerInfo.email}
              onChange={(e) => handleCustomerInfoChange('email', e.target.value)}
              required
              disabled={isProcessing}
              className="form-input"
            />
          </div>
        </div>

        {/* Card Information */}
        <div className="form-section">
          <h3>Card Details</h3>
          <div className="form-group">
            <label>Card Number</label>
            <CardNumberElement
              ref={cardNumberRef}
              options={{
                style: {
                  base: {
                    color: '#333',
                    fontFamily: 'Arial, sans-serif',
                    fontSize: '16px',
                    padding: '12px'
                  },
                  invalid: {
                    color: '#dc3545'
                  }
                },
                disabled: isProcessing
              }}
            />
          </div>

          <div className="form-row">
            <div className="form-group">
              <label>Expiration Date</label>
              <CardExpirationDateElement
                ref={expirationDateRef}
                options={{
                  style: {
                    base: {
                      color: '#333',
                      fontFamily: 'Arial, sans-serif',
                      fontSize: '16px',
                      padding: '12px'
                    },
                    invalid: {
                      color: '#dc3545'
                    }
                  },
                  disabled: isProcessing
                }}
              />
            </div>

            <div className="form-group">
              <label>CVC</label>
              <CardVerificationCodeElement
                ref={cvcRef}
                options={{
                  style: {
                    base: {
                      color: '#333',
                      fontFamily: 'Arial, sans-serif',
                      fontSize: '16px',
                      padding: '12px'
                    },
                    invalid: {
                      color: '#dc3545'
                    }
                  },
                  disabled: isProcessing
                }}
              />
            </div>
          </div>
        </div>

        {/* Submit Button */}
        <button
          type="submit"
          disabled={isProcessing}
          className={`submit-button ${isProcessing ? 'processing' : ''}`}
        >
          {isEncrypting ? 'Encrypting...' : 
           formState.isSubmitting ? 'Processing...' : 
           'Encrypt and Submit Payment'}
        </button>

        {/* Status Messages */}
        {hasError && (
          <div className="error-message">
            <strong>✗ Error:</strong> {hasError}
          </div>
        )}

        {formState.submitSuccess && (
          <div className="success-message">
            <strong>✓ Success!</strong> Payment data encrypted and processed successfully.
          </div>
        )}
      </form>
    </div>
  );
};

export default PaymentForm;
```

## Step 6: Add Styling

Create CSS for your payment form to provide a polished user experience.

```css title="src/components/PaymentForm.css"
.payment-form-container {
  max-width: 500px;
  margin: 0 auto;
  padding: 20px;
}

.payment-form {
  background: #fff;
  border-radius: 8px;
  padding: 30px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.payment-form h2 {
  margin-top: 0;
  color: #333;
  text-align: center;
}

.form-section {
  margin-bottom: 30px;
}

.form-section h3 {
  margin-bottom: 15px;
  color: #555;
  font-size: 18px;
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: #333;
}

.form-input {
  width: 100%;
  padding: 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
  transition: border-color 0.3s;
}

.form-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.form-input:disabled {
  background-color: #f8f9fa;
  cursor: not-allowed;
}

.form-row {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 15px;
}

.submit-button {
  width: 100%;
  padding: 15px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.3s;
}

.submit-button:hover:not(:disabled) {
  background-color: #0056b3;
}

.submit-button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
}

.submit-button.processing {
  background-color: #ffc107;
  color: #212529;
}

.error-message {
  margin-top: 15px;
  padding: 12px;
  background-color: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
}

.success-message {
  margin-top: 15px;
  padding: 12px;
  background-color: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
  border-radius: 4px;
}

/* Basis Theory Elements styling */
.bt-element {
  border: 1px solid #ddd;
  border-radius: 4px;
  transition: border-color 0.3s;
}

.bt-element:focus-within {
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.bt-element.bt-element--invalid {
  border-color: #dc3545;
}
```

## Step 7: Handle Encrypted Payloads in Your Backend

Your backend receives the encrypted payloads and creates tokens.

<Tabs className="bt-tabs" groupId="languages">
  <TabItem value="node" label="Node.js (Express)">

```javascript title="server.js"
const express = require('express');
const { BasisTheory } = require('@basis-theory/basis-theory-js');

const app = express();
app.use(express.json());

// Initialize Basis Theory with your Private Application key
const bt = new BasisTheory('<PRIVATE_API_KEY>');

app.post('/api/process-encrypted-payment', async (req, res) => {
    try {
        const { encryptedPayload, customerInfo } = req.body;

        console.log('Processing encrypted payment for:', customerInfo.email);

        // Create token using encrypted payload
        const token = await bt.tokens.create({
            type: 'card',
            encrypted: encryptedPayload,
            metadata: {
                customer_name: customerInfo.name,
                customer_email: customerInfo.email,
                processed_at: new Date().toISOString()
            }
        });

        console.log('Token created:', token.id);

        // Here you would typically:
        // 1. Process the payment using the token
        // 2. Store order information
        // 3. Send confirmation emails
        // 4. Update your database

        res.json({
            success: true,
            tokenId: token.id,
            message: 'Payment processed successfully',
            orderId: `order_${Date.now()}` // Example order ID
        });

    } catch (error) {
        console.error('Error processing encrypted payment:', error);
        
        res.status(500).json({
            success: false,
            error: error.message || 'Payment processing failed'
        });
    }
});

app.listen(3001, () => {
    console.log('Server running on port 3001');
});
```

  </TabItem>
  <TabItem value="nextjs" label="Next.js API Route">

```typescript title="pages/api/process-encrypted-payment.ts"
import type { NextApiRequest, NextApiResponse } from 'next';
import { BasisTheory } from '@basis-theory/basis-theory-js';

const bt = new BasisTheory(process.env.PRIVATE_API_KEY!);

interface RequestBody {
  encryptedPayload: string;
  customerInfo: {
    name: string;
    email: string;
  };
}

interface ResponseData {
  success: boolean;
  tokenId?: string;
  message?: string;
  orderId?: string;
  error?: string;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  try {
    const { encryptedPayload, customerInfo }: RequestBody = req.body;

    console.log('Processing encrypted payment for:', customerInfo.email);

    // Create token using encrypted payload
    const token = await bt.tokens.create({
      type: 'card',
      encrypted: encryptedPayload,
      metadata: {
        customer_name: customerInfo.name,
        customer_email: customerInfo.email,
        processed_at: new Date().toISOString()
      }
    });

    console.log('Token created:', token.id);

    // Process payment logic here...

    res.status(200).json({
      success: true,
      tokenId: token.id,
      message: 'Payment processed successfully',
      orderId: `order_${Date.now()}`
    });

  } catch (error) {
    console.error('Error processing encrypted payment:', error);
    
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Payment processing failed'
    });
  }
}
```

  </TabItem>
</Tabs>

## Step 8: Test Your Implementation

### Development Testing

1. **Start your React app**: `npm start`
2. **Start your backend**: Ensure your API endpoint is running
3. **Open the application**: Navigate to your React app
4. **Fill out the form**: Use test card data
5. **Submit**: Should show encryption progress and success

### Test Card Numbers

| Card Number | Brand | Description |
|-------------|-------|-------------|
| 4242424242424242 | Visa | Valid card for testing |
| 5555555555554444 | Mastercard | Valid card for testing |
| 378282246310005 | American Express | Valid card for testing |

### Validation Checklist

- [ ] Elements mount without errors
- [ ] Form validates required fields
- [ ] Encryption shows progress indicator
- [ ] Success message appears after submission
- [ ] Backend receives encrypted payload
- [ ] Token is created successfully
- [ ] Form resets after successful submission

## Error Handling Best Practices

### Frontend Error Handling

```tsx title="Enhanced Error Handling"
const useEncryptionWithRetry = () => {
  const [retryCount, setRetryCount] = useState(0);
  const maxRetries = 3;

  const encryptWithRetry = async (payload: any) => {
    try {
      return await encryptTokenPayload(payload);
    } catch (error) {
      if (retryCount < maxRetries) {
        setRetryCount(prev => prev + 1);
        // Wait briefly before retry
        await new Promise(resolve => setTimeout(resolve, 1000));
        return encryptWithRetry(payload);
      }
      throw error;
    }
  };

  return { encryptWithRetry, retryCount };
};
```

### Common Issues and Solutions

**"bt is undefined"**
- Ensure component is wrapped in `BasisTheoryProvider`
- Check that the provider has the correct API key
- Verify the provider is mounted before child components

**"Encryption key expired"**
- Check the `expires_at` date of your encryption key
- Generate a new key if expired
- Update your application configuration

**"Elements not mounting"**
- Verify refs are properly attached
- Check for console errors during mount
- Ensure Elements are inside BasisTheoryProvider

## Production Considerations

### Environment Configuration

```tsx title="Environment-based Config"
const getEncryptionConfig = () => {
  const isProduction = process.env.NODE_ENV === 'production';
  
  return {
    apiKey: isProduction 
      ? process.env.REACT_APP_BT_PUBLIC_KEY_PROD 
      : process.env.REACT_APP_BT_PUBLIC_KEY_DEV,
    keyId: isProduction 
      ? process.env.REACT_APP_ENCRYPTION_KEY_ID_PROD 
      : process.env.REACT_APP_ENCRYPTION_KEY_ID_DEV,
    publicKeyPEM: isProduction 
      ? process.env.REACT_APP_PUBLIC_KEY_PEM_PROD 
      : process.env.REACT_APP_PUBLIC_KEY_PEM_DEV
  };
};
```

### Performance Optimization

- **Lazy load encryption**: Only initialize when needed
- **Memoize configurations**: Cache encryption keys and settings
- **Debounce validation**: Avoid excessive validation calls
- **Optimize re-renders**: Use React.memo for expensive components

### Security Best Practices

- **Environment variables**: Store keys in environment variables
- **HTTPS only**: Never use HTTP in production
- **Key rotation**: Implement regular key rotation
- **Error logging**: Log errors securely without exposing sensitive data

## Advanced Patterns

### Custom Hook with Context

```tsx title="EncryptionContext.tsx"
import React, { createContext, useContext, ReactNode } from 'react';
import { useEncryption } from './useEncryption';

interface EncryptionContextType {
  encryptTokenPayload: (payload: any) => Promise<any>;
  isEncrypting: boolean;
  error: string | null;
}

const EncryptionContext = createContext<EncryptionContextType | undefined>(undefined);

export const EncryptionProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const encryption = useEncryption();
  
  return (
    <EncryptionContext.Provider value={encryption}>
      {children}
    </EncryptionContext.Provider>
  );
};

export const useEncryptionContext = () => {
  const context = useContext(EncryptionContext);
  if (!context) {
    throw new Error('useEncryptionContext must be used within EncryptionProvider');
  }
  return context;
};
```

## Next Steps

### Enhanced Features
- **Multi-step forms**: Break complex forms into steps
- **Form validation**: Add comprehensive client-side validation
- **Progress indicators**: Show detailed progress during encryption
- **Offline support**: Handle network failures gracefully

### Integration Options
- **State management**: Integrate with Redux or Zustand
- **Form libraries**: Use with Formik or React Hook Form
- **UI frameworks**: Style with Material-UI or Chakra UI
- **Testing**: Add unit and integration tests

For complete examples and advanced patterns, visit our [React encryption examples repository](https://github.com/Basis-Theory/react-encryption-examples). 